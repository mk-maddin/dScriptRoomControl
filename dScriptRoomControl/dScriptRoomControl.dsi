;************************************
;  dScriptRoomControl.dsi
;************************************

const       AppMajor    1                       ; version of this application.
const       AppMinor    3                       ; Note. This is NOT the Firmware version that is on the
const       AppVersion  (AppMajor*256)+AppMinor ; config status screen - that comes from Firmware.

flint32     initControl         ; rerun init on every AppMajor / AppMinor update
int32       FlashWritePending   ; indicate to config pages that a flash write is pending
int32       SystemCmdUpdated    ; used to tell when webpage updates "System_Cmd"

; config page 1 - Status #################################
string Module[30]
int32 VerMajor
int32 VerMinor
int32 AppVerMajor
int32 AppVerMinor
int32 BrdTemp
int32 Volts

; config page 2 - Network #################################
flstring    System_HostName[21]
flstring    System_IP[16]
flstring    System_SubNet[16]
flstring    System_Gateway[16]
flstring    System_DNS1[16]
flstring    System_DNS2[16]
flint8      System_EnableDHCP
string      DHCPChecked[8]

tcpip.ip        System_IP
tcpip.mask      System_SubNet
tcpip.hostname  System_HostName
tcpip.dns1      System_DNS1
tcpip.dns2      System_DNS2
tcpip.gateway   System_Gateway
tcpip.dhcp      System_EnableDHCP

; config page 3 - TCP/IP #################################
;string    System_AES_key[33]        ; temporary set as "string" not flstring for programming and testing

flint8      System_Cmd              ; set tcp/ip communication protocol ( 1=Modbus; 2=ASCII; 3=Binary ; 4=BinaryAES ) currently supported only 2 & 3
flint32     System_TcpPort          ; port used for tcp/ip communication (default=17123; default modbus=502) - used as dScriptServer listening port,too
flstring    System_AES_key[33]     ; encryption key for BinaryAES mode; This MUST be 32 characters long.   
flstring    App_dScriptServer[21]   ; the dScriptServer hostname/ip to send TCP/IP status update messages to

;int32     System_ModbusUID          ; temporary set as "int32" not flint32 for programming and testing
;int8      System_ModbusBaud         ; temporary set as "int8" not flint8 for programming and testing
;int8      System_ModbusParity       ; temporary set as "int8" not flint8 for programming and testing

flint32     System_ModbusUID
flint8      System_ModbusBaud
flint8      System_ModbusParity

string AsciiChecked[8]
string ModBusChecked[8]
string BinaryChecked[8]
string AESChecked[8]

tcpip.port  System_TcpPort
aes.key     System_AES_key
clientport  dScriptServer App_dScriptServer System_TcpPort 3000

; config page 4 - Webpage Security #################################
flint8      System_EnablePW
flstring    System_Password[201]
flint32     System_HttpPort
string      PWChecked[8]

html.password   System_Password
html.port       System_HttpPort
html.setup      System_EnablePW

; config page 99 - App Settings #################################
;int32   App_ClickSleep                  ; temporary set as "int32" not eeint32 for programming and testing
;int32   App_WindowShutterCT             ; temporary set as "int32" not eeint32 for programming and testing
;int32   App_DoorShutterCT               ; temporary set as "int32" not eeint32 for programming and testing
;int8    App_Lights                      ; temporary set as "int8" not eeint8 for programming and testing
;int8    App_Shutters                    ; temporary set as "int8" not eeint8 for programming and testing
;int8    App_LightsOffset                ; temporary set as "int8" not eeint8 for programming and testing

eeint32   App_ClickSleep                ; wait time for input clicks to complete for multi click handling
eeint32   App_WindowShutterCT           ; time it takes until a window shutter is fully closed from fully open
eeint32   App_DoorShutterCT             ; time it takes until a door shutter is fully closed from fully open
eeint8    App_Lights                    ; number of lights connected to relays
eeint8    App_Shutters                  ; number of shutters connected to relays
eeint8    App_LightsOffset              ; relay number where light connections begin (e.g. 10 means first light is at 10, second light at 9, third at 8 etc.)

;int8 App_ShutterType1                  ; temporary set as "int8" not eeint8 for programming and testing
;int8 App_ShutterType2                  ; temporary set as "int8" not eeint8 for programming and testing
;int8 App_ShutterType3                  ; temporary set as "int8" not eeint8 for programming and testing
;int8 App_ShutterType4                  ; temporary set as "int8" not eeint8 for programming and testing
;int8 App_ShutterType5                  ; temporary set as "int8" not eeint8 for programming and testing
;int8 App_ShutterType6                  ; temporary set as "int8" not eeint8 for programming and testing
;int8 App_ShutterType7                  ; temporary set as "int8" not eeint8 for programming and testing
;int8 App_ShutterType8                  ; temporary set as "int8" not eeint8 for programming and testing
;int8 App_ShutterType9                  ; temporary set as "int8" not eeint8 for programming and testing
;int8 App_ShutterType10                 ; temporary set as "int8" not eeint8 for programming and testing
;int8 App_ShutterType11                 ; temporary set as "int8" not eeint8 for programming and testing
;int8 App_ShutterType12                 ; temporary set as "int8" not eeint8 for programming and testing
;int8 App_ShutterType13                 ; temporary set as "int8" not eeint8 for programming and testing
;int8 App_ShutterType14                 ; temporary set as "int8" not eeint8 for programming and testing
;int8 App_ShutterType15                 ; temporary set as "int8" not eeint8 for programming and testing
;int8 App_ShutterType16                 ; temporary set as "int8" not eeint8 for programming and testing

eeint8 App_ShutterType1                   ; sets if shutter type is window or door for colosing time (0 = window; 1 = door)
eeint8 App_ShutterType2
eeint8 App_ShutterType3
eeint8 App_ShutterType4
eeint8 App_ShutterType5
eeint8 App_ShutterType6
eeint8 App_ShutterType7
eeint8 App_ShutterType8
eeint8 App_ShutterType9
eeint8 App_ShutterType10
eeint8 App_ShutterType11
eeint8 App_ShutterType12
eeint8 App_ShutterType13
eeint8 App_ShutterType14
eeint8 App_ShutterType15
eeint8 App_ShutterType16

; general helping variables #################################
int32   x
int32   Zero

; tcp/ip communication variables #################################

int32   tcpLength
string  tcpInBuf[1024]
string  tcpOutBuf[500]

int32   Nonce
int32   NonceIn

; application working variables #################################

string  App_Message[32]  ; status message output

int32 App_IOCtr1    ;counter values to follow up multi button press commands
int32 App_IOCtr2 
int32 App_IOCtr3
int32 App_IOCtr4
int32 App_IOCtr5
int32 App_IOCtr6
int32 App_IOCtr7
int32 App_IOCtr8

int8 App_ShutterLevel1
int8 App_ShutterLevel2
int8 App_ShutterLevel3
int8 App_ShutterLevel4
int8 App_ShutterLevel5
int8 App_ShutterLevel6
int8 App_ShutterLevel7
int8 App_ShutterLevel8
int8 App_ShutterLevel9
int8 App_ShutterLevel10
int8 App_ShutterLevel11
int8 App_ShutterLevel12
int8 App_ShutterLevel13
int8 App_ShutterLevel14
int8 App_ShutterLevel15
int8 App_ShutterLevel16

int32   App_WebInput              ; variable to identify a web input has happened
string  App_InpType[8]            ; variable writing the input type to webpage information input
int8    App_Sockets               ; number of sockets connected to relays ( =physical_relays-(light_relays+shutter_relays)) )

int8  App_ShutterStates[16]     ; stores the current status of shutters (0 = stopped; 1 = opening; 2 = closing)
int8  App_ShutterTLevels[16]    ; stores the "to be" level of a shutter ( 100 = fully open; 0 = fully closed)
int8  App_ShutterCLevels[16]    ; stores the current level of a shutter to prevent a lot of eeprom writings while moving ( 100 = fully open; 0 = fully closed)
;int8  App_ShutterLevels[16]     ; temporary set as "int8" not eeint8 for program testing
eeint8    App_ShutterLevels[16] ; to restore shutter closed/open level after power outage  ( 100 = fully open; 0 = fully closed)

int32 App_Debug                 ; variable to temporary store values and show them on app page (for Debug help)

; ###############################################################

thread main(const)
    App_Message="main"
    
    ; load the Module string with module name
    select system.ModuleID                          
        case 30 Module = "dS3484"
        case 31 Module = "dS1242"
        case 34 Module = "dS2824"
        case 35 Module = "dS378"
        case 36 Module = "TCP184"
    endselect

    if initControl != AppVersion Init()         ; init module if different from app version
    ;Init()                                      ; uncomment this line to force init

    ; load system firmware version
    VerMajor = system.VerMajor
    VerMinor = system.VerMinor

    AppVerMajor = AppMajor           ; set variables for status page display
    AppVerMinor = AppMinor
    threadstart ShowAppVersion       ; blink LEDs in app version used 
    
    do loop while system.Booting     ; wait for system to complete boot
    InitRestore()                    ; set/restore volatile variables

    InputsStart()                    ; start threads for physical & virtual input buttons
    threadstart TcpipCmd                ; start TCP/IP network server for communication
    threadstart dScriptServerContacter  ; start contacting the dScriptServer
    dScriptServerTrigger(0,0)           ; send "master I am here" information to server
    
    App_Message="ready"      
    do FlashWritePending = system.FlashPending ; keep up-to-date so webpage can access it
       threadsleep 100
    loop 
    threadsuspend
endthread

function Init()         ; initializes volatile/permantent variables with program defaults   
    for x = 1 to 6 ; flash red led to indicate init will run (3 seconds)                
        threadsleep 250
        LedRed = on
        threadsleep 250
        LedRed = off
    next
    App_Message="Init"

    ; config page 2 - Network
    System_HostName = Module
    System_IP = "192.168.0.124"
    System_SubNet = "255.255.255.0"
    System_Gateway = "192.168.0.1"
    System_DNS1 = "192.168.0.1"
    System_DNS2 = "8.8.8.8"
    System_EnableDHCP = on

    ; config page 3 - TCP/IP
    System_Cmd = 3              ; set tcp/ip communication protocol ( 1=Modbus; 2=ASCII; 3=Binary ; 4=BinaryAES ) currently supported only 2 & 3
    System_TcpPort = 17123      ; port used for tcp/ip communication (default=17123; default modbus=502) - used as dScriptServer listening port,too
    App_dScriptServer = ""      ; default should be '' - dScriptServer to send TCP/IP status update messages to
    
    System_ModbusUID = 1
    System_ModbusBaud = 1               ; 9600
    System_ModbusParity = 1             ; even

    System_AES_key = "This MUST be 32 characters long." ; encryption key for BinaryAES mode; This MUST be 32 characters long.
                   ; "12345678901234567890123456789012"
                   
    ; config page 4 - Webpage Security
    System_EnablePW = 1
    System_Password = ""    
    System_HttpPort = 80

    ; config page 99 - App Settings
    App_ClickSleep = 800        ; we have 0.8 seconds time to press button multiple times
    App_WindowShutterCT = 10000 ; windows shutter needs 55 seconds to close
    App_DoorShutterCT = 20000   ; door shutter needs 110 seconds (1 minute and 50 seconds) to close

    App_ShutterType1 = 0        ; set closing time by default to window (0 = window; 1 = door)
    App_ShutterType2 = App_ShutterType1
    App_ShutterType3 = App_ShutterType1
    App_ShutterType4 = App_ShutterType1
    App_ShutterType5 = App_ShutterType1
    App_ShutterType6 = App_ShutterType1
    App_ShutterType7 = App_ShutterType1
    App_ShutterType8 = App_ShutterType1
    App_ShutterType9 = App_ShutterType1
    App_ShutterType10 = App_ShutterType1
    App_ShutterType11 = App_ShutterType1
    App_ShutterType12 = App_ShutterType1
    App_ShutterType13 = App_ShutterType1
    App_ShutterType14 = App_ShutterType1
    App_ShutterType15 = App_ShutterType1
    App_ShutterType16 = App_ShutterType1

    int32 ShutterID
    for ShutterID = 1 to 16             ; set current % closed of all shutters
        App_ShutterLevels[ShutterID-1] = 100  ; 100 = fully open; 0 = fully closed
    next
        
    select system.ModuleID                          ; Releay ID where the lights begin/end (counted downwards)
        case 30 App_LightsOffset = 4                ;"dS3484" - 4 physical relays
                App_Lights = 2                      ; set nubmer of lights default
                App_Shutters = 1                    ; set number of shutters default
        case 31 App_LightsOffset = 2                ;"dS1242" - 2 physical relays
                App_Lights = 2                      ; set nubmer of lights default
                App_Shutters = 0                    ; set number of shutters default
        case 34 App_LightsOffset = 10               ;"dS2824" - 24 physical relays
                App_Lights = 4                      ; set nubmer of lights default
                App_Shutters = 3                    ; set number of shutters default
        case 35 App_LightsOffset = 8                ;"dS378" - 8 physical relays
                App_Lights = 2                      ; set nubmer of lights default
                App_Shutters = 2                    ; set number of shutters default
        case 36 App_LightsOffset = 4                ;"TCP184" - 4 physical relays
                App_Lights = 2                      ; set nubmer of lights default
                App_Shutters = 1                    ; set number of shutters default
    endselect

    initControl = AppVersion
    return
endfunction
function InitRestore()  ; restore temporary from volatile variables
    App_Message="InitRestore"
    App_Debug=-99   ; set nonse initial value to see value change in case of 0
    threadstart UpdateCheckedStrings ; keep config page checkboxes updated
    SystemCmdUpdated=1               ; trigger UpdateCheckedStrings during startup
       
    App_IOCtr1 = 0              ; reset counters for multi button presses
    App_IOCtr2 = App_IOCtr1
    App_IOCtr3 = App_IOCtr1
    App_IOCtr4 = App_IOCtr1
    App_IOCtr5 = App_IOCtr1
    App_IOCtr6 = App_IOCtr1
    App_IOCtr7 = App_IOCtr1
    App_IOCtr8 = App_IOCtr1

    int32 ShutterID
    for ShutterID = 1 to 16
        App_ShutterStates[ShutterID-1] = 0 ; 0 = stopped; 1 = opening; 2 = closing
        App_ShutterCLevels[ShutterID-1] = App_ShutterLevels[ShutterID-1]    ; set current shutter level to last one saved
        App_ShutterTLevels[ShutterID-1] = App_ShutterLevels[ShutterID-1]    ; set target shutter level to last one saved (to prevent moving at startup)
    next

    threadstart CalcVoltsTemp        ; keep config page volt & temp updated
    threadstart ValidateCountLightsAndShutters ; ensure lights and shutters are not oversized    
    threadstart UpdateShutterStates  ; keep shutter values on index page updated
    return
endfunction

function SetIO(int32 ioID, int32 State)         ; subroutine called from Ascii and Binary modes to setting IO (valid states are  0=off, 1=on)
    select ioID
        case 1 IO1 = State
        case 2 IO2 = State
        case 3 IO3 = State
        case 4 IO4 = State
        case 5 IO5 = State
        case 6 IO6 = State
        case 7 IO7 = State
        case 8 IO8 = State
    endselect
    return
endfunction
function SetRelay(int32 RelayID, int32 State)   ; subroutine setting a relay (valid states are  0=off, 1=on, 2 or other=toggle)
    select RelayID
        case 1
            if State >= 2 then Rly1 = Rly1 ^ 1
            else Rly1 = State endif
        case 2
            if State >= 2 then Rly2 = Rly2 ^ 1
            else Rly2 = State endif
        case 3
            if State >= 2 then Rly3 = Rly3 ^ 1
            else Rly3 = State endif
        case 4
            if State >= 2 then Rly4 = Rly4 ^ 1
            else Rly4 = State endif
        case 5
            if State >= 2 then Rly5 = Rly5 ^ 1
            else Rly5 = State endif
        case 6
            if State >= 2 then Rly6 = Rly6 ^ 1
            else Rly6 = State endif
        case 7
            if State >= 2 then Rly7 = Rly7 ^ 1
            else Rly7 = State endif
        case 8
            if State >= 2 then Rly8 = Rly8 ^ 1
            else Rly8 = State endif
        case 9
            if State >= 2 then Rly9 = Rly9 ^ 1
            else Rly9 = State endif
        case 10
            if State >= 2 then Rly10 = Rly10 ^ 1
            else Rly10 = State endif
        case 11
            if State >= 2 then Rly11 = Rly11 ^ 1
            else Rly11 = State endif
        case 12
            if State >= 2 then Rly12 = Rly12 ^ 1
            else Rly12 = State endif
        case 13
            if State >= 2 then Rly13 = Rly13 ^ 1
            else Rly13 = State endif
        case 14
            if State >= 2 then Rly14 = Rly14 ^ 1
            else Rly14 = State endif
        case 15
            if State >= 2 then Rly15 = Rly15 ^ 1
            else Rly15 = State endif
        case 16
            if State >= 2 then Rly16 = Rly16 ^ 1
            else Rly16 = State endif
        case 17
            if State >= 2 then Rly17 = Rly17 ^ 1
            else Rly17 = State endif
        case 18
            if State >= 2 then Rly18 = Rly18 ^ 1
            else Rly18 = State endif
        case 19
            if State >= 2 then Rly19 = Rly19 ^ 1
            else Rly19 = State endif
        case 20
            if State >= 2 then Rly20 = Rly20 ^ 1
            else Rly20 = State endif
        case 21
            if State >= 2 then Rly21 = Rly21 ^ 1
            else Rly21 = State endif
        case 22
            if State >= 2 then Rly22 = Rly22 ^ 1
            else Rly22 = State endif
        case 23
            if State >= 2 then Rly23 = Rly23 ^ 1
            else Rly23 = State endif
        case 24
            if State >= 2 then Rly24 = Rly24 ^ 1
            else Rly24 = State endif
        case 25
            if State >= 2 then Rly25 = Rly25 ^ 1
            else Rly25 = State endif
        case 26
            if State >= 2 then Rly26 = Rly26 ^ 1
            else Rly26 = State endif
        case 27
            if State >= 2 then Rly27 = Rly27 ^ 1
            else Rly27 = State endif
        case 28
            if State >= 2 then Rly28 = Rly28 ^ 1
            else Rly28 = State endif
        case 29
            if State >= 2 then Rly29 = Rly29 ^ 1
            else Rly29 = State endif
        case 30
            if State >= 2 then Rly30 = Rly30 ^ 1
            else Rly30 = State endif
        case 31
            if State >= 2 then Rly31 = Rly31 ^ 1
            else Rly31 = State endif
        case 32
            if State >= 2 then Rly32 = Rly32 ^ 1
            else Rly32 = State endif
        else App_Message="Invalid relay id"
    endselect
    return
endfunction
function int8 GetRelay(int32 RelayID)           ; returns the current status of a specific relay 0=off, 1=on
    select RelayID
        case 1  if Rly1  == off then return 0 else return 1 endif
        case 2  if Rly2  == off then return 0 else return 1 endif
        case 3  if Rly3  == off then return 0 else return 1 endif
        case 4  if Rly4  == off then return 0 else return 1 endif
        case 5  if Rly5  == off then return 0 else return 1 endif
        case 6  if Rly6  == off then return 0 else return 1 endif
        case 7  if Rly7  == off then return 0 else return 1 endif
        case 8  if Rly8  == off then return 0 else return 1 endif
        case 9  if Rly9  == off then return 0 else return 1 endif
        case 10 if Rly10 == off then return 0 else return 1 endif
        case 11 if Rly11 == off then return 0 else return 1 endif
        case 12 if Rly12 == off then return 0 else return 1 endif
        case 13 if Rly13 == off then return 0 else return 1 endif
        case 14 if Rly14 == off then return 0 else return 1 endif
        case 15 if Rly15 == off then return 0 else return 1 endif
        case 16 if Rly16 == off then return 0 else return 1 endif
        case 17 if Rly17 == off then return 0 else return 1 endif
        case 18 if Rly18 == off then return 0 else return 1 endif
        case 19 if Rly19 == off then return 0 else return 1 endif
        case 20 if Rly20 == off then return 0 else return 1 endif
        case 21 if Rly21 == off then return 0 else return 1 endif
        case 22 if Rly22 == off then return 0 else return 1 endif
        case 23 if Rly23 == off then return 0 else return 1 endif
        case 24 if Rly24 == off then return 0 else return 1 endif
        case 25 if Rly25 == off then return 0 else return 1 endif
        case 26 if Rly26 == off then return 0 else return 1 endif
        case 27 if Rly27 == off then return 0 else return 1 endif
        case 28 if Rly28 == off then return 0 else return 1 endif
        case 29 if Rly29 == off then return 0 else return 1 endif
        case 30 if Rly30 == off then return 0 else return 1 endif
        case 31 if Rly31 == off then return 0 else return 1 endif
        case 32 if Rly32 == off then return 0 else return 1 endif
        else App_Message="Invalid realy ID"
    endselect
    return 0
endfunction

function InputsStart()  ; start threads for physical & virtual input buttons
    App_Message="InputsStart"
    ; start all input threads for multi handling
    threadstart Input1IOCtr
    threadstart Input2IOCtr
    threadstart Input3IOCtr
    threadstart Input4IOCtr
    threadstart Input5IOCtr
    threadstart Input6IOCtr
    threadstart Input7IOCtr
    threadstart Input8IOCtr

    threadstart InputWeb

    select system.ModuleID                          ; start only needed physical input threads
        case 30 ;"dS3484"
            threadstart Input1
            threadstart Input2
            threadstart Input3
            threadstart Input4
            threadstart Input5
            threadstart Input6
            threadstart Input7
            threadstart Input8
        case 31 ;"dS1242"
            threadstart Input1
            threadstart Input2
            threadstart Input3
            threadstart Input4
        case 34 ;"dS2824"
            threadstart Input1
            threadstart Input2
            threadstart Input3
            threadstart Input4
            threadstart Input5
            threadstart Input6
            threadstart Input7
            threadstart Input8
        case 35 ;"dS378"
            threadstart Input1
            threadstart Input2
            threadstart Input3
            threadstart Input4
            threadstart Input5
            threadstart Input6
            threadstart Input7
        case 36 ;"TCP184"
            threadstart Input1
            threadstart Input2
            threadstart Input3
            threadstart Input4
            threadstart Input5
            threadstart Input6
            threadstart Input7
            threadstart Input8
    endselect
    return
endfunction
function InputHandler(int32 InpID, int32 Clicks) ; handles inputs dynamically based on defined # lights & # shutters
    App_Message="InputHandler"
    if InpID <= App_Lights then ; process lights
        LightClicksHandler(InpID,Clicks) ; App_LightsOffset tells us where light relays start - we subtract the inut id from there to get the light relay attached to input
    else
        int32 ShuttersOffset
        ShuttersOffset = 0
        
        if ( App_Lights // 2 ) == 1 and ( App_Shutters // 2 ) == 0 ShuttersOffset = 1  ; other button between light & shutter buttons exists
        if InpID == ( App_Lights + ShuttersOffset ) then ; other button between light & shutter buttons was pressed
            OtherClicksHandler(InpID, Clicks) return
        elseif InpID > ( App_Lights + App_Shutters + ShuttersOffset ) then ; other button after all light & shutter buttons was pressed
            OtherClicksHandler(InpID, Clicks) return
        endif
        
        ShutterClicksHandler((InpID - App_Lights - ShuttersOffset),Clicks); shutter button was pressed
    endif        
    return
endfunction

function ShutterClicksHandler(int32 ShutterID, int32 Clicks)    ; handles all multiclicks related to shutters
    App_InpType="Shutter"
    select Clicks
        case 1  App_Message="open shutter"
            if App_ShutterStates[ShutterID-1] == 0 then App_ShutterTLevels[ShutterID-1] = 100  ; if shutter does not move currently, open it ;100 = fully open
            else                                        ; if shutter moves (independently of open/close) stop it
                App_ShutterTLevels[ShutterID-1] = App_ShutterCLevels[ShutterID-1] endif ; set the target level to current level for stopping by thread
            ShutterStartThread(ShutterID)           ; start shutter thread only if needed        
        case 2  App_Message="close shutter"
            if App_ShutterStates[ShutterID-1] == 0 then App_ShutterTLevels[ShutterID-1] = 0  ; if shutter does not move currently close it ; 0 = fully closed                
            else                                        ; if shutter moves (independently of open/close) stop it
                App_ShutterTLevels[ShutterID-1] = App_ShutterCLevels[ShutterID-1] endif ; set the target level to current level for stopping by thread
            ShutterStartThread(ShutterID)           ; start shutter thread only if needed
        case 3 App_Message="open ALL shutters" ; on this controller
            for ShutterID = 1 to App_Shutters
                App_ShutterTLevels[ShutterID-1] = 100
                ShutterStartThread(ShutterID)
            next
        case 4 App_Message="close ALL shutters" ; on this controller
            for ShutterID = 1 to App_Shutters
                App_ShutterTLevels[ShutterID-1] = 0
                ShutterStartThread(ShutterID)
            next
        else App_Message="Unhandled click count"
    endselect
    return
endfunction
function LightClicksHandler(int32 LightID, int32 Clicks)        ; handles all multiclicks related to lights
    App_InpType="Light"
    select Clicks
        case 1  App_Message="toggle light" SetLight(LightID,2) 
        case 2  App_Message="enable ALL lights" ; on this controller
            for LightID = 1 to App_Lights
                SetLight(LightID,1)
            next
        case 3  App_Message="disable ALL lights" ; on this controller
            for LightID = 1 to App_Lights
                SetLight(LightID,0)
            next
        else App_Message="Unhandled click count"
    endselect
    return
endfunction
function OtherClicksHandler(int32 InpID, int32 Clicks)          ; handles all multiclicks not related to anything else
    App_InpType="Other"
    select Clicks
        case 0 App_Message="Unhandled click count" ; dummy value (for syntax correctness
        else App_Message="Unhandled click count"
    endselect
    return
endfunction

function SetLight(int32 LightID, int32 Action)      ; Sets the state of a light (Action: 0=OFF; 1=ON; 2 or any other=Toggle)
    App_Message="SetLight"
    int32 RelayID
    RelayID=App_LightsOffset-(LightID-1)            ; calculate the corresponding relay id for light id
    if Action == 0 then SetRelay(RelayID, off)
    elseif Action == 1 then SetRelay(RelayID, on)
    else SetRelay(RelayID, 2) endif ; 2 or any other means toggle relay
    dScriptServerTrigger(81, LightID)               ; trigger refresh on the dScriptServer
    return      
endfunction
function SetSocket(int32 SocketID, int32 Action)    ; Sets the state of a Socket (Action: 1=ON; 2=OFF; 0 or any other=Toggle)
    App_Message="SetSocket"
    int32 RelayID
    RelayID=App_PhysRelays-(SocketID-1)             ; calculate the corresponding relay id for socket id
    if Action == 1 then SetRelay(RelayID, on)
    elseif Action == 2 then SetRelay(RelayID, off)
    else SetRelay(RelayID, 3) endif ;3 means toggle relay
    dScriptServerTrigger(83, SocketID)              ; trigger refresh on the dScriptServer 
    return      
endfunction

function ShutterOpen(int32 ShutterID)           ; open the shutter
     App_Message="ShutterOpen"
     App_ShutterStates[ShutterID-1] = 1
     ShutterID = ShutterID*2 ; replace ShutterID with ID of second realy of shutter
     SetRelay(ShutterID, off)
     SetRelay((ShutterID - 1), on)
     return       
endfunction
function ShutterClose(int32 ShutterID)          ; close the shutter (assumes one is for open; one relay for closing)
     App_Message="ShutterClose"
     App_ShutterStates[ShutterID-1] = 2
     ShutterID = ShutterID*2 ; replace ShutterID with ID of second realy of shutter
     SetRelay((ShutterID - 1), off)
     SetRelay(ShutterID, on)
     return
endfunction
function ShutterClose2(int32 ShutterID)         ; close the shutter (assumes one relay defines move/not move; the other one the drection - open or close)
     App_Message="ShutterClose2"
     App_ShutterStates[ShutterID-1] = 2
     ShutterID = ShutterID*2 ; replace ShutterID with ID of second realy of shutter
     SetRelay((ShutterID - 1), on)
     SetRelay(ShutterID, on)
     return
endfunction
function ShutterStop(int32 ShutterID)           ; stop the shutter   
    App_Message="ShutterStop"
    App_ShutterStates[ShutterID-1] = 0
    ShutterID = ShutterID*2 ; replace ShutterID with ID of second realy of shutter    
    SetRelay((ShutterID - 1), off)
    SetRelay(ShutterID, off)
    return
endfunction
function ShutterMoveDirection(int32 ShutterID)  ; set the shutter moevement state based on target variable
    App_Message="ShutterMoveDirection"
    ; it is very important to READ App_ShutterLevels[ShutterID-1] in the following statements only
    if App_ShutterTLevels[ShutterID-1] == App_ShutterCLevels[ShutterID-1] then ShutterStop(ShutterID) 
    elseif App_ShutterTLevels[ShutterID-1] > App_ShutterCLevels[ShutterID-1] then ShutterOpen(ShutterID)    ;100 = fully open;
    elseif App_ShutterTLevels[ShutterID-1] < App_ShutterCLevels[ShutterID-1] then ShutterClose(ShutterID)   ;0 = fully closed
    else 
        App_Message="Invalid shutter levels"
        ShutterStop(ShutterID)
    endif
    return
endfunction

function ShutterStartThread(int32 ShutterID)    ; starts shutter thread, but only if not already running
    App_Message="ShutterStartThread"
    if App_ShutterStates[ShutterID-1] == 0 then
        select ShutterID
            case 1  threadstart MoveShutter1
            case 2  threadstart MoveShutter2
            case 3  threadstart MoveShutter3
            case 4  threadstart MoveShutter4
            case 5  threadstart MoveShutter5
            case 6  threadstart MoveShutter6
            case 7  threadstart MoveShutter7
            case 8  threadstart MoveShutter8
            case 9  threadstart MoveShutter9
            case 10 threadstart MoveShutter10
            case 11 threadstart MoveShutter11
            case 12 threadstart MoveShutter12
            case 13 threadstart MoveShutter13
            case 14 threadstart MoveShutter14
            case 15 threadstart MoveShutter15
            case 16 threadstart MoveShutter16
        endselect
    endif
    return
endfunction
function int32 ShutterGetClosingTime(int32 ShutterID)       ; returns the closing time for defined shutter based on shutter ID
    select ShutterID
        case 1  return ShutterGetClosingTimeHelp(App_ShutterType1)
        case 2  return ShutterGetClosingTimeHelp(App_ShutterType2)
        case 3  return ShutterGetClosingTimeHelp(App_ShutterType3)
        case 4  return ShutterGetClosingTimeHelp(App_ShutterType4)
        case 5  return ShutterGetClosingTimeHelp(App_ShutterType5)
        case 6  return ShutterGetClosingTimeHelp(App_ShutterType6)
        case 7  return ShutterGetClosingTimeHelp(App_ShutterType7)
        case 8  return ShutterGetClosingTimeHelp(App_ShutterType8)
        case 9  return ShutterGetClosingTimeHelp(App_ShutterType9)
        case 10 return ShutterGetClosingTimeHelp(App_ShutterType10)
        case 11 return ShutterGetClosingTimeHelp(App_ShutterType11)
        case 12 return ShutterGetClosingTimeHelp(App_ShutterType12)
        case 13 return ShutterGetClosingTimeHelp(App_ShutterType13)
        case 14 return ShutterGetClosingTimeHelp(App_ShutterType14)
        case 15 return ShutterGetClosingTimeHelp(App_ShutterType15)
        case 16 return ShutterGetClosingTimeHelp(App_ShutterType16)        
    endselect
    return 0  
endfunction
function int32 ShutterGetClosingTimeHelp(int8 ShutterMode)  ; returns the closing time based on given shutter mode (0 = window; 1 = door)
    select ShutterMode
        case 0  return App_WindowShutterCT
        case 1  return App_DoorShutterCT
        else    return App_WindowShutterCT
    endselect
    return 0
endfunction
function ShutterMoveThreadX(int32 ShutterID)    ; function used by every MoveShutterX thread
    int32 ShutterCT   
    App_ShutterCLevels[ShutterID-1] = App_ShutterLevels[ShutterID-1] ; temporary working variable to prevent a lot of writes to eeprom
    ShutterCT = ShutterGetClosingTime(ShutterID)                     ; define closing time for door or window

    do while App_ShutterTLevels[ShutterID-1] != App_ShutterCLevels[ShutterID-1]
        if App_ShutterStates[ShutterID-1] == 0 then           ; currently stopped
            if App_ShutterTLevels[ShutterID-1] != App_ShutterCLevels[ShutterID-1] then
                ShutterMoveDirection(ShutterID) endif       ; if status is not correct and we are not moving we have to            
        elseif App_ShutterStates[ShutterID-1] == 1  then      ; currently opening
            if App_ShutterTLevels[ShutterID-1] < App_ShutterCLevels[ShutterID-1] then 
                ShutterMoveDirection(ShutterID)             ; if we are opening and the target is smaller than the current level we move into wrong direction
            else App_ShutterCLevels[ShutterID-1]+=1 endif     ; 100 = fully open
        elseif App_ShutterStates[ShutterID-1] == 2            ; currently closing
            if App_ShutterTLevels[ShutterID-1] > App_ShutterCLevels[ShutterID-1] then 
                ShutterMoveDirection(ShutterID)             ; if we are closing and the target is bigger than the current level we move into wrong direction
            else App_ShutterCLevels[ShutterID-1]-=1 endif     ; 0 = fully closed             
        endif       
        threadsleep (ShutterCT/100) ; sleep 1 percentage of closing
    loop
    
    ShutterStop(ShutterID)
    App_ShutterLevels[ShutterID-1] = App_ShutterCLevels[ShutterID-1] ; write the finished status back into eeprom
    dScriptServerTrigger(82, ShutterID)              ; trigger refresh on the dScriptServer
    return
endfunction

function Binary()                               ; processes incoming / outgpoing binary tcp/ip traffic
    if tcpLength > 0 then 
        NonceIn = Nonce                         ; not using AES, so just make it equal do BinaryDo will work OK.
        BinaryDo()                              ; actually execute the binary command
        if(tcpLength) tcpip.Write(tcpOutBuf, tcpLength)
    endif
    return
endfunction     
function BinaryAES()                            ; processes incoming / outgpoing AES encrypted binary tcp/ip traffic
    if tcpLength > 31 then                      ; needs to be at least 32 bytes 
        aes.decrypt(tcpInBuf, 16)
        x = 12
        NonceIn = tcpInBuf.GetNumBinary(x, 4)                   
        for x = 0 to 15 
            tcpOutBuf[x] = 0
        next
        BinaryDo()                              ; actually execute the binary command
        aes.encrypt(tcpOutBuf, 16)
        tcpip.Write(tcpOutBuf, 32)
    endif
    return
endfunction
function BinaryDo()                             ; function interpreting the binary TCP/IP query and returning corresponding values / actions
    tcpLength = 0
    select tcpInBuf[0]
        case 0x30   BinaryGetStatus()           ; decimal 48
        case 0x31   BinarySetRelay()            ; decimal 49
        case 0x32   BinarySetOutput()           ; decimal 50
        case 0x33   BinaryGetRelay()            ; decimal 51
        case 0x34   BinaryGetInput()            ; decimal 52
        case 0x35   BinaryGetAnalogue()         ; decimal 53
        case 0x36   BinaryGetCounter()          ; decimal 54
        case 0x40   BinarySetLight()            ; decimal 64
        case 0x41   BinarySetShutter()          ; decimal 65
        case 0x42   BinarySetSocket()           ; decimal 66
        case 0x50   BinaryGetConfig()           ; decimal 80
        case 0x51   BinaryGetLight()            ; decimal 81
        case 0x52   BinaryGetShutter()          ; decimal 82
        case 0x53   BinaryGetSocket()           ; decimal 83
        else App_Message="Invalid binary cmd"
    endselect
    return
endfunction 
function BinaryGetStatus()                      ; GS, Get Status - returns 8 bytes.
    tcpOutBuf[0] = system.ModuleID      ; ( 30=dS3484; 31=dS1242; 34=dS2824; 35=dS378; 36=TCP184 )
    tcpOutBuf[1] = VerMajor             ; Firmware version - major
    tcpOutBuf[2] = VerMinor             ; Firmware version - minor
    tcpOutBuf[3] = AppVerMajor          ; Application Firmware version - major
    tcpOutBuf[4] = AppVerMinor          ; Application Firmware version - minor
    tcpOutBuf[5] = Volts                ; Volts*10, 125 = 12.5v
    tcpOutBuf[6] = BrdTemp>>8           ; internal temperature*10, high byte
    tcpOutBuf[7] = BrdTemp&255          ; internal temperature*10, low byte, (combined to 16 bits, 267 = 26.7 degrees C)
    Nonce = system.Random
    tcpOutBuf[12] = Nonce >> 24
    tcpOutBuf[13] = Nonce >> 16         ; insert Nonce - just in case we are being called by AES mode 
    tcpOutBuf[14] = Nonce >> 8
    tcpOutBuf[15] = Nonce
    tcpLength = 8
    return
endfunction
function BinarySetRelay()                       ; SR, Set Relay - relay num, state, pulse time/state (4 bytes), total 7 byte command
    x = 3                                           ; used as a temporary index (originally used with value PulseTime)
    x = tcpInBuf.GetNumBinary(x, 4)                 ; originally got 4 byte pulse time ( no longer supported)
    select tcpInBuf[1]
        case 1 to 32
            if Nonce == NonceIn then                ; process command only Nonce counting is correct
                SetRelay(tcpInBuf[1],tcpInBuf[2])   ; set the relay 
                tcpOutBuf[0] = 0 endif              ; ACK
        else tcpOutBuf[0] = tcpInBuf[1]             ; NACK, unknown relay number, send relay number as NACK                 
    endselect
    Nonce = system.Random
    tcpOutBuf[12] = Nonce >> 24
    tcpOutBuf[13] = Nonce >> 16                     ; insert Nonce - just in case we are being called by AES mode 
    tcpOutBuf[14] = Nonce >> 8
    tcpOutBuf[15] = Nonce
    tcpLength = 1
    return
endfunction
function BinarySetOutput()                      ; SO, Set Output - output num, state, total 3 byte command
    select tcpInBuf[1]
        case 1 to 8
            if Nonce == NonceIn then                ; process command only Nonce counting is correct 
                SetIO(tcpInBuf[1], tcpInBuf[2])     ; set the output    
                tcpOutBuf[0] = 0 endif              ; ACK
        else tcpOutBuf[0] = tcpInBuf[1]             ; NACK, unknown I/O number, send number as NACK                 
    endselect
    Nonce = system.Random
    tcpOutBuf[12] = Nonce >> 24
    tcpOutBuf[13] = Nonce >> 16                     ; insert Nonce - just in case we are being called by AES mode 
    tcpOutBuf[14] = Nonce >> 8
    tcpOutBuf[15] = Nonce
    tcpLength = 1
    return
endfunction
function BinaryGetRelay()                       ; GR, Get Relay - 1st is requested relay, 2nd,4rd,4th are packed relays,
    tcpOutBuf[0] = GetRelay(tcpInBuf[1])
    tcpOutBuf[1] = 0
    tcpOutBuf[2] = 0
    tcpOutBuf[3] = 0
    tcpOutBuf[4] = 0            
    if Rly1==on then tcpOutBuf[4] = tcpOutBuf[4] | 0x01 endif
    if Rly2==on then tcpOutBuf[4] = tcpOutBuf[4] | 0x02 endif
    if Rly3==on then tcpOutBuf[4] = tcpOutBuf[4] | 0x04 endif
    if Rly4==on then tcpOutBuf[4] = tcpOutBuf[4] | 0x08 endif
    if Rly5==on then tcpOutBuf[4] = tcpOutBuf[4] | 0x10 endif
    if Rly6==on then tcpOutBuf[4] = tcpOutBuf[4] | 0x20 endif
    if Rly7==on then tcpOutBuf[4] = tcpOutBuf[4] | 0x40 endif
    if Rly8==on then tcpOutBuf[4] = tcpOutBuf[4] | 0x80 endif
    if Rly9==on then tcpOutBuf[3] = tcpOutBuf[3] | 0x01 endif
    if Rly10==on then tcpOutBuf[3] = tcpOutBuf[3] | 0x02 endif
    if Rly11==on then tcpOutBuf[3] = tcpOutBuf[3] | 0x04 endif
    if Rly12==on then tcpOutBuf[3] = tcpOutBuf[3] | 0x08 endif
    if Rly13==on then tcpOutBuf[3] = tcpOutBuf[3] | 0x10 endif
    if Rly14==on then tcpOutBuf[3] = tcpOutBuf[3] | 0x20 endif
    if Rly15==on then tcpOutBuf[3] = tcpOutBuf[3] | 0x40 endif
    if Rly16==on then tcpOutBuf[3] = tcpOutBuf[3] | 0x80 endif                  
    if Rly17==on then tcpOutBuf[2] = tcpOutBuf[2] | 0x01 endif
    if Rly18==on then tcpOutBuf[2] = tcpOutBuf[2] | 0x02 endif
    if Rly19==on then tcpOutBuf[2] = tcpOutBuf[2] | 0x04 endif
    if Rly20==on then tcpOutBuf[2] = tcpOutBuf[2] | 0x08 endif
    if Rly21==on then tcpOutBuf[2] = tcpOutBuf[2] | 0x10 endif
    if Rly22==on then tcpOutBuf[2] = tcpOutBuf[2] | 0x20 endif
    if Rly23==on then tcpOutBuf[2] = tcpOutBuf[2] | 0x40 endif
    if Rly24==on then tcpOutBuf[2] = tcpOutBuf[2] | 0x80 endif          
    if Rly25==on then tcpOutBuf[1] = tcpOutBuf[1] | 0x01 endif
    if Rly26==on then tcpOutBuf[1] = tcpOutBuf[1] | 0x02 endif
    if Rly27==on then tcpOutBuf[1] = tcpOutBuf[1] | 0x04 endif
    if Rly28==on then tcpOutBuf[1] = tcpOutBuf[1] | 0x08 endif
    if Rly29==on then tcpOutBuf[1] = tcpOutBuf[1] | 0x10 endif
    if Rly30==on then tcpOutBuf[1] = tcpOutBuf[1] | 0x20 endif
    if Rly31==on then tcpOutBuf[1] = tcpOutBuf[1] | 0x40 endif
    if Rly32==on then tcpOutBuf[1] = tcpOutBuf[1] | 0x80 endif
    tcpLength = 5
    return
endfunction
function BinaryGetInput()                       ; GI, Get Input - 1st is requested input, 2nd is packed inputs
    tcpOutBuf[0] = 0
    tcpOutBuf[1] = 0
    select tcpInBuf[1]
        case 1  if IO1==on tcpOutBuf[0] = 1 
        case 2  if IO2==on tcpOutBuf[0] = 1 
        case 3  if IO3==on tcpOutBuf[0] = 1 
        case 4  if IO4==on tcpOutBuf[0] = 1 
        case 5  if IO5==on tcpOutBuf[0] = 1 
        case 6  if IO6==on tcpOutBuf[0] = 1 
        case 7  if IO7==on tcpOutBuf[0] = 1 
        case 8  if IO8==on tcpOutBuf[0] = 1 
    endselect
    if IO1==on then tcpOutBuf[1] = tcpOutBuf[1] | 0x01 endif
    if IO2==on then tcpOutBuf[1] = tcpOutBuf[1] | 0x02 endif
    if IO3==on then tcpOutBuf[1] = tcpOutBuf[1] | 0x04 endif
    if IO4==on then tcpOutBuf[1] = tcpOutBuf[1] | 0x08 endif
    if IO5==on then tcpOutBuf[1] = tcpOutBuf[1] | 0x10 endif
    if IO6==on then tcpOutBuf[1] = tcpOutBuf[1] | 0x20 endif
    if IO7==on then tcpOutBuf[1] = tcpOutBuf[1] | 0x40 endif
    if IO8==on then tcpOutBuf[1] = tcpOutBuf[1] | 0x80 endif
    tcpLength = 2
    return
endfunction
function BinaryGetAnalogue()                    ; GA, Get Analog - 1st is high byte, 2nd is low byte of input - returns all 8 analog inputs (some may actually be digital)
    for x=0 to 7                    ; initialize an empty tcpOutBuf of 16 bytes 
        tcpOutBuf[(x*2)] = 0>>8
        tcpOutBuf[((x*2)+1)] = 0&255
    next 
    tcpLength = 16                  ; lenght reply is always 16 bytes

    ; fill return based on module and its connectors ;( 30=dS3484; 31=dS1242; 34=dS2824; 35=dS378; 36=TCP184 )
    if system.ModuleID == 30 or system.ModuleID == 31 then      ;( 30=dS3484; 31=dS1242 )
        x = AD1                 ; returns first 2 analog inputs
        tcpOutBuf[0] = x>>8           
        tcpOutBuf[1] = x&255  
        x = AD2
        tcpOutBuf[2] = x>>8
        tcpOutBuf[3] = x&255
    endif
    if system.ModuleID == 30 then                               ;( 30=dS3484 )
        x = AD3                 ; returns analog inputs 3 & 4
        tcpOutBuf[4] = x>>8
        tcpOutBuf[5] = x&255  
        x = AD4
        tcpOutBuf[6] = x>>8
        tcpOutBuf[7] = x&255  
    endif     
    if system.ModuleID == 34 or system.ModuleID == 35 or system.ModuleID == 36 then ;( 34=dS2824; 35=dS378; 36=TCP184 )
        tcpOutBuf[0] = IO1>>8   ; returns first 7 analog inputs (some may actually be digital)
        tcpOutBuf[1] = IO1&255  
        tcpOutBuf[2] = IO2>>8
        tcpOutBuf[3] = IO2&255  
        tcpOutBuf[4] = IO3>>8
        tcpOutBuf[5] = IO3&255  
        tcpOutBuf[6] = IO4>>8
        tcpOutBuf[7] = IO4&255  
        tcpOutBuf[8] = IO5>>8
        tcpOutBuf[9] = IO5&255  
        tcpOutBuf[10] = IO6>>8
        tcpOutBuf[11] = IO6&255     
        tcpOutBuf[12] = IO7>>8
        tcpOutBuf[13] = IO7&255
    endif
    if system.ModuleID == 34 or system.ModuleID == 36 then  ;( 34=dS2824; 36=TCP184 )
        tcpOutBuf[14] = IO8>>8  ; returns the 9 analog input (some may actually be digital)
        tcpOutBuf[15] = IO8&255
    endif
    return
endfunction
function BinaryGetCounter()                     ; GC, Get Counter - Counter num, 2 byte command returning 8 bytes
    tcpOutBuf[0] = 0>>24                      ; sorry - this case is just a dummy to ensure backwards compatibility
    tcpOutBuf[1] = 0>>16                      ; it will always return 0 for all counters
    tcpOutBuf[2] = 0>>8
    tcpOutBuf[3] = 0&255              
    tcpOutBuf[4] = 0>>24
    tcpOutBuf[5] = 0>>16     
    tcpOutBuf[6] = 0>>8
    tcpOutBuf[7] = 0&255     
    tcpLength = 8
    return
endfunction
function BinarySetLight()                       ; SL, Set Light - light id, state, total 3 byte command
    select tcpInBuf[1]
        case 1 to App_Lights
            if Nonce == NonceIn then                ; process command only Nonce counting is correct 
                SetLight(tcpInBuf[1], tcpInBuf[2])  ; process command    
                tcpOutBuf[0] = 0 endif              ; ACK
        else tcpOutBuf[0] = tcpInBuf[1]             ; NACK, unknown light id, send number as NACK                 
    endselect
    Nonce = system.Random
    tcpOutBuf[12] = Nonce >> 24
    tcpOutBuf[13] = Nonce >> 16                     ; insert Nonce - just in case we are being called by AES mode 
    tcpOutBuf[14] = Nonce >> 8
    tcpOutBuf[15] = Nonce
    tcpLength = 1
    return
endfunction
function BinarySetShutter()                     ; SH, Set Shutter - shutter id, state, total 3 byte command
    select tcpInBuf[1]
        case 1 to App_Shutters          
            if Nonce == NonceIn then    ; process command only Nonce counting is correct   
                if tcpInBuf[2] > 100 then App_ShutterTLevels[tcpInBuf[1]-1] = 100   ; set the shutter target state to fully open (100)
                elseif tcpInBuf[2] < 0 then App_ShutterTLevels[tcpInBuf[1]-1] = 0   ; set the shutter target state to fully closed (0)
                else App_ShutterTLevels[tcpInBuf[1]-1] = tcpInBuf[2] endif          ; take the shutter target state from given value
                ShutterStartThread(tcpInBuf[1])                                       ; start shutter thread only if needed
                tcpOutBuf[0] = 0 endif      ; ACK
            else tcpOutBuf[0] = tcpInBuf[1] ; NACK, unknown I/O number, send number as NACK                
    endselect
    Nonce = system.Random
    tcpOutBuf[12] = Nonce >> 24
    tcpOutBuf[13] = Nonce >> 16         ; insert Nonce - just in case we are being called by AES mode 
    tcpOutBuf[14] = Nonce >> 8
    tcpOutBuf[15] = Nonce
    tcpLength = 1
    return
endfunction
function BinarySetSocket()                      ; SC, Set Socket - socket id, state, total 3 byte command
    if App_Sockets == 0 then tcpOutBuf[0] = tcpInBuf[1]
    else
        select tcpInBuf[1]
            case 1 to App_Sockets
                select tcpInBuf[2]                      ; correct tcpInBuf2 to match SetSocket function
                    case 0x00 tcpInBuf[2] = 2           ; off
                    case 0x01 tcpInBuf[2] = 1           ; on
                    else tcpInBuf[2] = 0                ; toggle
                endselect
                if Nonce == NonceIn then                ; process command only Nonce counting is correct 
                    SetSocket(tcpInBuf[1], tcpInBuf[2]) ; process command    
                    tcpOutBuf[0] = 0 endif              ; ACK
            else tcpOutBuf[0] = tcpInBuf[1]             ; NACK, unknown light id, send number as NACK                 
        endselect
    endif
    Nonce = system.Random
    tcpOutBuf[12] = Nonce >> 24
    tcpOutBuf[13] = Nonce >> 16                     ; insert Nonce - just in case we are being called by AES mode 
    tcpOutBuf[14] = Nonce >> 8
    tcpOutBuf[15] = Nonce
    tcpLength = 1
    return
endfunction
function BinaryGetConfig()                      ; GO, Get Config - returns 8 bytes
    tcpOutBuf[0] = system.ModuleID      ; ( 30=dS3484; 31=dS1242; 34=dS2824; 35=dS378; 36=TCP184 )
    ;TO-DO: fix incorrect reply of System_TcpPort
    tcpOutBuf[1] = 0;System_TcpPort>>8    ; PortID the local tcp/ip server is listening to (lowbyte)
    tcpOutBuf[2] = 0;System_TcpPort&255   ; PortID the local tcp/ip server is listening to (highbyte) (combined to 16 bits)
    tcpOutBuf[3] = System_Cmd           ; tcp/ip communication protocol ( 1=Modbus; 2=ASCII; 3=Binary ; 4=BinaryAES )
    tcpOutBuf[4] = App_PhysRelays       ; number of physical relays (depends on the module)
    tcpOutBuf[5] = App_Lights           ; number of lights connected to relays
    tcpOutBuf[6] = App_Shutters         ; number of shutters connected to relays
    tcpOutBuf[7] = App_Sockets          ; number of sockets connected to relays
    tcpLength = 8
    return
endfunction
function BinaryGetLight()                       ; GL, Get Light - returns 1 byte
    int8 RelayID
    RelayID=App_LightsOffset-(tcpInBuf[1]-1)    ; replace light id with rleay id
    tcpOutBuf[0] = GetRelay(RelayID)
    tcpLength = 1
    return
endfunction
function BinaryGetShutter()                     ; GH, Get Shutter - returns 2 bytes
    tcpOutBuf[1] = App_ShutterStates[tcpInBuf[1]-1]
    if App_ShutterStates[tcpInBuf[1]-1] == 0 then           ; currently stopped
        tcpOutBuf[0] = App_ShutterLevels[tcpInBuf[1]-1]     ; use the 'Levels' value which is used for restoring, too
    else tcpOutBuf[0] = App_ShutterCLevels[tcpInBuf[1]-1]   ; use the 'CLevels' value which is used for correct moving
    endif
    tcpLength = 2
    return
endfunction
function BinaryGetSocket()                      ; GC, Get Socket - returns 1 byte
    int8 RelayID
    RelayID=App_PhysRelays-(tcpInBuf[1]-1)      ; replace socket id with rleay id
    tcpOutBuf[0] = GetRelay(RelayID)            
    if tcpOutBuf[0] == 0 then tcpOutBuf[0] = 1       ; sockets are usually connected to NC instead of NO - so invert here
    elseif tcpOutBuf[0] == 1 tcpOutBuf[0] = 0 endif
    tcpLength = 1
    return
endfunction

function dScriptServerTrigger(int8 cmdID, int8 objID)      ; trigger requests on status updates to dScriptServer
    string  clientBuf[2]                               ; all Get XXXXX commands in binary are two byte commands
    int32   clientLength                               ;   based on this we are able to trigger an update on any specific object that changed
    
    if App_dScriptServer[0] == 0 then           ; skip if no dScriptServer is defined
        ;App_Message="No dScriptServer"
        return 
    endif
    
    ;App_Message="dScriptServerTrigger"
    select cmdID
        case 0  ; "master I am here" trigger to server - usually used on boot only
            clientBuf[0] = cmdID clientBuf[1] = 0
        case 48 ; decimal value for: GS, Get Status
            clientBuf[0] = cmdID clientBuf[1] = objID
        case 51 ; decimal value for: GR, Get Relay      ;TO-DO: call this function from SetRelay
            clientBuf[0] = cmdID clientBuf[1] = objID
        case 52 ; decimal value for: GI, Get Input      ;TO-DO: call this function from InputHandler
            clientBuf[0] = cmdID clientBuf[1] = objID
        case 53 ; decimal value for: GA, Get Analog     ;TO-DO: call this function from ????
            clientBuf[0] = cmdID clientBuf[1] = objID
        case 54 ; decimal value for: GC, Get Counter    ;TO-DO: call this function from ????
            clientBuf[0] = cmdID clientBuf[1] = objID
        case 80 ; decimal value for: GO, Get Config
            clientBuf[0] = cmdID clientBuf[1] = objID
        case 81 ; decimal value for: GL, Get Light
            clientBuf[0] = cmdID clientBuf[1] = objID
        case 82 ; decimal value for: GH, Get Shutter
            clientBuf[0] = cmdID clientBuf[1] = objID
        case 83 ; decimal value for: GC, Get Socket
            clientBuf[0] = cmdID clientBuf[1] = objID
        else App_Message="Invalid dScriptServer cmdID"
            return
    endselect
    dScriptServer.Write(clientBuf,3, clientBuf, clientLength)
    return
endfunction

thread ShowAppVersion(const) ; blink LEDs in app version used  (on demand)
    for x = 1 to AppMajor    ; flash blue led to indicate the AppVerMajor loaded
        threadsleep 500 LedBlue = on
        threadsleep 500 LedBlue = off
    next
    for x = 1 to AppMinor    ; flash green led to indicate the AppVerMinor loaded
        threadsleep 200 LedGreen = on
        threadsleep 200 LedGreen = off
    next
    threadsuspend
endthread

thread CalcVoltsTemp(1000)   ; update the systems voltage and temperature on config page (every 1 second)
    BrdTemp = ((TS1*3223)-500000)/1000  ; thread runs once per second to keep
    Volts = PSU*18369/100000            ; board temperature and volts updated
    threadsuspend
endthread

thread UpdateCheckedStrings(SystemCmdUpdated) ; update the checkboxes used on config page (whenever SystemCmdUpdated is set)
    ; different communication channels not used yet
    ;if System_Cmd==1 then ModBusChecked="checked" else ModBusChecked=" " endif
    ;if System_Cmd==2 then AsciiChecked="checked" else AsciiChecked=" " endif
    if System_Cmd==3 then BinaryChecked="checked" else BinaryChecked=" " endif
    if System_Cmd==4 then AESChecked="checked" else AESChecked=" " endif
    if System_EnablePW==1 then PWChecked="checked" else PWChecked=" " endif
    if System_EnableDHCP==1 then DHCPChecked="checked" else DHCPChecked=" " endif
    SystemCmdUpdated = 0;
    threadsuspend
endthread

thread UpdateShutterStates(1000) ; update webpage variables for shutter states (every 1 second)
    int8 ShutterID
    int8 ShutterState
    
    for ShutterID = 1 to 16
        if App_ShutterStates[ShutterID-1] == 0 then
            ShutterState = App_ShutterLevels[ShutterID-1]
        else ShutterState = App_ShutterCLevels[ShutterID-1] endif

         select ShutterID
            case 1  App_ShutterLevel1  = ShutterState
            case 2  App_ShutterLevel2  = ShutterState
            case 3  App_ShutterLevel3  = ShutterState
            case 4  App_ShutterLevel4  = ShutterState
            case 5  App_ShutterLevel5  = ShutterState
            case 6  App_ShutterLevel6  = ShutterState
            case 7  App_ShutterLevel7  = ShutterState
            case 8  App_ShutterLevel8  = ShutterState
            case 9  App_ShutterLevel9  = ShutterState
            case 10 App_ShutterLevel10 = ShutterState
            case 11 App_ShutterLevel11 = ShutterState
            case 12 App_ShutterLevel12 = ShutterState
            case 13 App_ShutterLevel13 = ShutterState
            case 14 App_ShutterLevel14 = ShutterState
            case 15 App_ShutterLevel15 = ShutterState
            case 16 App_ShutterLevel16 = ShutterState
         endselect
    next

endthread

thread ValidateCountLightsAndShutters(1000) ; validate the number of lights and shutters set (every 1 second)
    int32 MaxRelays
    MaxRelays = 32                                         ; all boards have a maximum of 32 physical & virtual relays

    if App_Lights < 0 App_Lights = 0                       ; no negative number of lights
    if App_Shutters < 0 App_Shutters = 0                   ; no negative number of shutters
    
    ; check maximum number of arrays
    if (App_Lights + (App_Shutters*2)) > MaxRelays then     ; error here - number of relays is oversize
        if App_Lights > MaxRelays App_Lights = MaxRelays    ; never more lights than relays
    
        ; the following assumes that lights always have higher priority than shutters
        if (App_Lights + (App_Shutters*2)) > MaxRelays      ; if still more shutters & lights than relays available
            MaxRelays = MaxRelays - App_Lights              ; number of free relays
            if ( MaxRelays // 2 ) == 1 MaxRelays-=1         ; if number of free relays is Odd - make -1 (one free relay since shutters always need 2 relays)
            App_Shutters = MaxRelays/2
        endif
    endif

    ; ensure the App_LightsOffset is bigger or equal to the number of relays required by lights + shutters (since lights are counted backwards)
    if (App_Lights + (App_Shutters*2)) > App_LightsOffset then
        App_LightsOffset = (App_Lights + (App_Shutters*2)) 
    endif

    ; set the corresponding number of sockets (physical relays - lights offset)
    if App_LightsOffset >= App_PhysRelays then App_Sockets = 0 ;no negative app sockets 
    else App_Sockets = App_PhysRelays - App_LightsOffset endif
    threadsuspend        
endthread

thread dScriptServerContacter(600000)     ; try to contact the dScriptServer at least every 10 minutes
    dScriptServerTrigger(0,0)       ; send "master I am here" information to server   
endthread

thread Input1(input Inp1)   ; triggered as soon as physical IO receives high
    App_IOCtr1 +=1
    threadsuspend
endthread
thread Input2(input Inp2)   ; triggered as soon as physical IO receives high
    App_IOCtr2 +=1
    threadsuspend
endthread
thread Input3(input Inp3)   ; triggered as soon as physical IO receives high
    App_IOCtr3 +=1
    threadsuspend
endthread
thread Input4(input Inp4)   ; triggered as soon as physical IO receives high
    App_IOCtr4 +=1
    threadsuspend
endthread
thread Input5(input Inp5)   ; triggered as soon as physical IO receives high
    App_IOCtr5 +=1
    threadsuspend
endthread
thread Input6(input Inp6)   ; triggered as soon as physical IO receives high
    App_IOCtr6 +=1
    threadsuspend
endthread
thread Input7(input Inp7)   ; triggered as soon as physical IO receives high
    App_IOCtr7 +=1
    threadsuspend
endthread
thread Input8(input Inp8)   ; triggered as soon as physical IO receives high
    App_IOCtr8 +=1
    threadsuspend
endthread

thread InputWeb(App_WebInput)   ; triggered as soon as a web button was pressed
    select App_WebInput
        case 1 App_IOCtr1 +=1
        case 2 App_IOCtr2 +=1
        case 3 App_IOCtr3 +=1
        case 4 App_IOCtr4 +=1
        case 5 App_IOCtr5 +=1
        case 6 App_IOCtr6 +=1
        case 7 App_IOCtr7 +=1
        case 8 App_IOCtr8 +=1
    endselect
    App_WebInput=0
endthread

thread Input1IOCtr(App_IOCtr1)  ; triggered as soon as multi press counter is changed
    threadsleep App_ClickSleep
    int32 Clicks
    Clicks=App_IOCtr1
    App_IOCtr1 = 0  ; ensure the CtrVal is reset for sure
    InputHandler(1,Clicks)
    threadsuspend        
endthread
thread Input2IOCtr(App_IOCtr2)  ; triggered as soon as multi press counter is changed
    threadsleep App_ClickSleep
    int32 Clicks
    Clicks=App_IOCtr2
    App_IOCtr2 = 0  ; ensure the CtrVal is reset for sure
    InputHandler(2,Clicks)
    threadsuspend        
endthread
thread Input3IOCtr(App_IOCtr3)  ; triggered as soon as multi press counter is changed
    threadsleep App_ClickSleep
    int32 Clicks
    Clicks=App_IOCtr3
    App_IOCtr3 = 0  ; ensure the CtrVal is reset for sure
    InputHandler(3,Clicks)
    threadsuspend        
endthread
thread Input4IOCtr(App_IOCtr4)  ; triggered as soon as multi press counter is changed
    threadsleep App_ClickSleep
    int32 Clicks
    Clicks=App_IOCtr4
    App_IOCtr4 = 0  ; ensure the CtrVal is reset for sure
    InputHandler(4,Clicks)
    threadsuspend        
endthread
thread Input5IOCtr(App_IOCtr5)  ; triggered as soon as multi press counter is changed
    threadsleep App_ClickSleep
    int32 Clicks
    Clicks=App_IOCtr5
    App_IOCtr5 = 0  ; ensure the CtrVal is reset for sure
    InputHandler(5,Clicks)
    threadsuspend        
endthread
thread Input6IOCtr(App_IOCtr6)  ; triggered as soon as multi press counter is changed
    threadsleep App_ClickSleep
    int32 Clicks
    Clicks=App_IOCtr6
    App_IOCtr6 = 0  ; ensure the CtrVal is reset for sure
    InputHandler(6,Clicks)
    threadsuspend        
endthread
thread Input7IOCtr(App_IOCtr7)  ; triggered as soon as multi press counter is changed
    threadsleep App_ClickSleep
    int32 Clicks
    Clicks=App_IOCtr7
    App_IOCtr7 = 0  ; ensure the CtrVal is reset for sure
    InputHandler(7,Clicks)
    threadsuspend        
endthread
thread Input8IOCtr(App_IOCtr8)  ; triggered as soon as multi press counter is changed
    threadsleep App_ClickSleep
    int32 Clicks
    Clicks=App_IOCtr8
    App_IOCtr8 = 0  ; ensure the CtrVal is reset for sure
    InputHandler(8,Clicks)
    threadsuspend        
endthread

thread MoveShutter1(const)   ; handles the shutter movement and state
    App_Message="MoveShutter1"
    ShutterMoveThreadX(1)
    threadsuspend
endthread
thread MoveShutter2(const)   ; handles the shutter movement and state
    ShutterMoveThreadX(2)
    threadsuspend
endthread
thread MoveShutter3(const)   ; handles the shutter movement and state
    ShutterMoveThreadX(3)
    threadsuspend
endthread
thread MoveShutter4(const)   ; handles the shutter movement and state
    ShutterMoveThreadX(4)
    threadsuspend
endthread
thread MoveShutter5(const)   ; handles the shutter movement and state
    ShutterMoveThreadX(5)
    threadsuspend
endthread
thread MoveShutter6(const)   ; handles the shutter movement and state
    ShutterMoveThreadX(6)
    threadsuspend
endthread
thread MoveShutter7(const)   ; handles the shutter movement and state
    ShutterMoveThreadX(7)
    threadsuspend
endthread
thread MoveShutter8(const)   ; handles the shutter movement and state
    ShutterMoveThreadX(8)
    threadsuspend
endthread
thread MoveShutter9(const)   ; handles the shutter movement and state
    ShutterMoveThreadX(9)
    threadsuspend
endthread
thread MoveShutter10(const)  ; handles the shutter movement and state
    ShutterMoveThreadX(10)
    threadsuspend
endthread
thread MoveShutter11(const)  ; handles the shutter movement and state
    ShutterMoveThreadX(11)
    threadsuspend
endthread
thread MoveShutter12(const)  ; handles the shutter movement and state
    ShutterMoveThreadX(12)
    threadsuspend
endthread
thread MoveShutter13(const)  ; handles the shutter movement and state
    ShutterMoveThreadX(13)
    threadsuspend
endthread
thread MoveShutter14(const)  ; handles the shutter movement and state
    ShutterMoveThreadX(14)
    threadsuspend
endthread
thread MoveShutter15(const)  ; handles the shutter movement and state
    ShutterMoveThreadX(15)
    threadsuspend
endthread
thread MoveShutter16(const)  ; handles the shutter movement and state
    ShutterMoveThreadX(16)
    threadsuspend
endthread

thread TcpipCmd(tcpip)                  ; starts the actual tcp/ip server with defined protocol
    tcpip.Read(tcpInBuf, tcpLength)     ; read the tcp/ip data into the buffer and 
        select System_Cmd               ; branch to appropiate handler as defined in System_Cmd.
            ;case 1  ModBus()           ; not supported for now
            ;case 2  Ascii()            ; not supported for now
            case 3  Binary()
            case 4  BinaryAES()
        endselect
    threadsuspend
endthread

