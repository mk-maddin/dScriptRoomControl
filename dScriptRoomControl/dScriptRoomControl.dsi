;************************************
;  dScriptRoomControl.dsi
;
; This file is the main program file 
; containing all logic and programming parts.
;
;************************************

thread main(const)
    App_Message="main"

    ; get the devices mac address
    tcpip.ReadMacAddr(System_MAC)   ; read the systems MAC Address
    System_MACString={h02} System_MAC[0] ~ ":" ~ {h02} System_MAC[1] ~ ":" ~ {h02} System_MAC[2] ~ ":" ~ {h02} System_MAC[3] ~ ":" ~ {h02} System_MAC[4] ~ ":" ~ {h02} System_MAC[5]
    
    ; load the Module string with module name
    select system.ModuleID                          
        case 30 Module = "dS3484"
        case 31 Module = "dS1242"
        case 34 Module = "dS2824"
        case 35 Module = "dS378"
        case 36 Module = "TCP184"
        case 42 Module = "dS2832"
    endselect

    if initControl != AppVersion Init()        ; init module if different from app version
    ;Init()                                      ; uncomment this line to force init
    LedRed = on                                 ; indicate that system is still busy booting - physical
    FlashWritePending = 1                       ; indicate that system is still busy booting - config page

    ; load system firmware version
    VerMajor = system.VerMajor
    VerMinor = system.VerMinor

    AppVerMajor = AppMajor           ; set variables for status page display
    AppVerMinor = AppMinor
    threadstart ShowAppVersion       ; blink LEDs in app version used 

    do loop while system.Booting     ; wait for system to complete boot
    InitRestore()                    ; set/restore volatile variables
    
    InputsStart()                    ; start threads for physical & virtual input buttons
    threadstart TcpipCmd                 ; start TCP/IP network server for communication
    threadstart dScriptServerContacter   ; start contact handling thread for dScriptServer
    threadsleep 1000
    dScriptServerTrigger(0,0)            ; initial contact to dScriptServer (with time delay required)
    
    App_Message="ready"
    LedRed = off                        ; indicate that system is completed booting - physical
    FlashWritePending = 0               ; indicate that system is completed booting - config page
    LedGreen = on
    do FlashWritePending = system.FlashPending ; keep up-to-date so webpage can access it
       threadsleep 100
    loop
    threadsuspend
endthread

function Init()         ; initializes volatile/permantent variables with program defaults   
    for x = 1 to 6 ; flash red led to indicate init will run (3 seconds)                
        threadsleep 250
        LedRed = on
        threadsleep 250
        LedRed = off
    next
    App_Message="Init"

    ; config page 2 - Network
    System_HostName = "dS-" ~ {h02} System_MAC[0] ~ {h02} System_MAC[1] ~ {h02} System_MAC[2] ~ {h02} System_MAC[3] ~ {h02} System_MAC[4] ~ {h02} System_MAC[5]
    System_IP = "192.168.0.124"
    System_SubNet = "255.255.255.0"
    System_Gateway = "192.168.0.1"
    System_DNS1 = "192.168.0.1"
    System_DNS2 = "8.8.8.8"
    System_EnableDHCP = on

    ; config page 3 - TCP/IP
    System_Cmd = 3              ; set tcp/ip communication protocol ( 1=Modbus; 2=ASCII; 3=Binary ; 4=BinaryAES ) currently supported only 2 & 3
    System_TcpPort = 17123      ; port used for tcp/ip communication (default=17123; default modbus=502) - used as dScriptServer listening port,too
    App_dScriptServer = ""      ; default should be '' - dScriptServer to send TCP/IP status update messages to
    
    System_ModbusUID = 1
    System_ModbusBaud = 1               ; 9600
    System_ModbusParity = 1             ; even

    System_AES_key = "This MUST be 32 characters long." ; encryption key for BinaryAES mode; This MUST be 32 characters long.
                   ; "12345678901234567890123456789012"
                   
    ; config page 4 - Webpage Security
    System_EnablePW = 1
    System_Password = ""    
    System_HttpPort = 80

    ; config page 7 - Input / Output
    App_EnableAutoIO = 1            ; enable auto IO matching by default
    
    App_IOType1 = 0                 ; set the IO input type by default to auto (0 = Auto Type; 1 = Light; 2 = Shutter; 3 = Socket; 4 = Motion)
    App_IOType2 = App_IOType1
    App_IOType3 = App_IOType1
    App_IOType4 = App_IOType1
    App_IOType5 = App_IOType1
    App_IOType6 = App_IOType1
    App_IOType7 = App_IOType1
    App_IOType8 = App_IOType1

    App_IOSet1 = ""                 ; set the default entityID csv (which entityIDs are triggered on I/O active) to empty
    App_IOSet2 = App_IOSet1
    App_IOSet3 = App_IOSet1
    App_IOSet4 = App_IOSet1
    App_IOSet5 = App_IOSet1
    App_IOSet6 = App_IOSet1
    App_IOSet7 = App_IOSet1
    App_IOSet8 = App_IOSet1

    ; config page 98 - Shutters

    App_ShutterType1 = 1                    ; set the shutter type by default to roller ( 0 = auto; 1 = roller; 2 = raffstore; 3 = jealousy )
    App_ShutterType2 = App_ShutterType1
    App_ShutterType3 = App_ShutterType1
    App_ShutterType4 = App_ShutterType1
    App_ShutterType5 = App_ShutterType1
    App_ShutterType6 = App_ShutterType1
    App_ShutterType7 = App_ShutterType1
    App_ShutterType8 = App_ShutterType1
    App_ShutterType9 = App_ShutterType1
    App_ShutterType10 = App_ShutterType1
    App_ShutterType11 = App_ShutterType1
    App_ShutterType12 = App_ShutterType1
    App_ShutterType13 = App_ShutterType1
    App_ShutterType14 = App_ShutterType1
    App_ShutterType15 = App_ShutterType1
    App_ShutterType16 = App_ShutterType1

    App_ShutterCT1 = 10000                ; set closing time by default to 10 seconds
    App_ShutterCT2 = App_ShutterCT1
    App_ShutterCT3 = App_ShutterCT1
    App_ShutterCT4 = App_ShutterCT1
    App_ShutterCT5 = App_ShutterCT1
    App_ShutterCT6 = App_ShutterCT1
    App_ShutterCT7 = App_ShutterCT1
    App_ShutterCT8 = App_ShutterCT1
    App_ShutterCT9 = App_ShutterCT1
    App_ShutterCT10 = App_ShutterCT1
    App_ShutterCT11 = App_ShutterCT1
    App_ShutterCT12 = App_ShutterCT1
    App_ShutterCT13 = App_ShutterCT1
    App_ShutterCT14 = App_ShutterCT1
    App_ShutterCT15 = App_ShutterCT1
    App_ShutterCT16 = App_ShutterCT1

    int32 ShutterID
    for ShutterID = 1 to 16             ; set current % closed of all shutters
        App_ShutterLevels[ShutterID-1] = 100  ; 100 = fully open; 0 = fully closed
    next

    ; config page 99 - Entities
    App_ShutterRelayCT = 1      ; recommended way to connect shutters to relays is in row
    App_ClickSleep = 800        ; we have 0.8 seconds time to press button multiple times
           
    select system.ModuleID                          ; Releay ID where the lights begin/end (counted downwards)
        case 30 App_LightsOffset = 3                ;"dS3484" - 4 physical relays
                App_Lights = 1                      ; set nubmer of lights default
                App_Shutters = 1                    ; set number of shutters default
               ;App_Sockets = 1                     ; number of sockets is calculated automatically (PhysRelays - Shutters*2 - lights)
        case 31 App_LightsOffset = 1                ;"dS1242" - 2 physical relays
                App_Lights = 1                      ; set nubmer of lights default
                App_Shutters = 0                    ; set number of shutters default
               ;App_Sockets = 1                     ; number of sockets is calculated automatically (PhysRelays - Shutters*2 - lights)
        case 34 App_LightsOffset = 12               ;"dS2824" - 24 physical relays
                App_Lights = 4                      ; set nubmer of lights default
                App_Shutters = 3                    ; set number of shutters default
               ;App_Sockets = 12                    ; number of sockets is calculated automatically (PhysRelays - Shutters*2 - lights)
        case 35 App_LightsOffset = 4                ;"dS378" - 8 physical relays
                App_Lights = 2                      ; set nubmer of lights default
                App_Shutters = 1                    ; set number of shutters default
               ;App_Sockets = 4                     ; number of sockets is calculated automatically (PhysRelays - Shutters*2 - lights)
        case 36 App_LightsOffset = 3                ;"TCP184" - 4 physical relays
                App_Lights = 1                      ; set nubmer of lights default
                App_Shutters = 1                    ; set number of shutters default
               ;App_Sockets = 1                     ; number of sockets is calculated automatically (PhysRelays - Shutters*2 - lights)
    endselect

    initControl = AppVersion
    return
endfunction
function InitRestore()  ; restore temporary from volatile variables_
    App_Message="InitRestore"
    App_Debug=-99   ; set nonse initial value to see value change in case of 0
    threadstart UpdateCheckedStrings ; keep config page checkboxes updated
    SystemCmdUpdated=1               ; trigger UpdateCheckedStrings during startup
    threadstart UpdateEntityCounts   ; keep entity counts updated
    App_EntityCountsUpdated=1        ; trigger UpdateEntityCounts during startup
            
    App_IOCtr1 = 0              ; reset counters for multi button presses
    App_IOCtr2 = App_IOCtr1
    App_IOCtr3 = App_IOCtr1
    App_IOCtr4 = App_IOCtr1
    App_IOCtr5 = App_IOCtr1
    App_IOCtr6 = App_IOCtr1
    App_IOCtr7 = App_IOCtr1
    App_IOCtr8 = App_IOCtr1

    App_IOActive[0] = 0         ; reset states for tracking active input buttons pressed
    App_IOActive[1] = App_IOActive[0]
    App_IOActive[2] = App_IOActive[0]
    App_IOActive[3] = App_IOActive[0]
    App_IOActive[4] = App_IOActive[0]
    App_IOActive[5] = App_IOActive[0]
    App_IOActive[6] = App_IOActive[0]
    App_IOActive[7] = App_IOActive[0]
    
    int32 ShutterID
    for ShutterID = 1 to 16
        App_RaffstoreIOs[ShutterID-1] = 0                                   ; initialize with zero InpID
        App_ShutterStates[ShutterID-1] = 0                                  ; 0 = stopped; 1 = opening; 2 = closing
        App_ShutterCLevels[ShutterID-1] = App_ShutterLevels[ShutterID-1]    ; set current shutter level to last one saved
        App_ShutterTLevels[ShutterID-1] = App_ShutterLevels[ShutterID-1]    ; set target shutter level to last one saved (to prevent moving at startup)
    next
    threadstart CalcVoltsTemp        ; keep config page volt & temp updated
    threadstart UpdateShutterStates  ; keep shutter values on index page updated
    return
endfunction

function SetIO(int32 ioID, int32 State)         ; subroutine called from Ascii and Binary modes to setting IO (valid states are  0=off, 1=on)
    select ioID
        case 1 IO1 = State
        case 2 IO2 = State
        case 3 IO3 = State
        case 4 IO4 = State
        case 5 IO5 = State
        case 6 IO6 = State
        case 7 IO7 = State
        case 8 IO8 = State
    endselect
    return
endfunction
function SetRelay(int32 RelayID, int32 State)   ; subroutine setting a relay (valid states are  0=off, 1=on, 2 or other=toggle)
    select RelayID
        case 1
            if State >= 2 then Rly1 = Rly1 ^ 1
            else Rly1 = State endif
        case 2
            if State >= 2 then Rly2 = Rly2 ^ 1
            else Rly2 = State endif
        case 3
            if State >= 2 then Rly3 = Rly3 ^ 1
            else Rly3 = State endif
        case 4
            if State >= 2 then Rly4 = Rly4 ^ 1
            else Rly4 = State endif
        case 5
            if State >= 2 then Rly5 = Rly5 ^ 1
            else Rly5 = State endif
        case 6
            if State >= 2 then Rly6 = Rly6 ^ 1
            else Rly6 = State endif
        case 7
            if State >= 2 then Rly7 = Rly7 ^ 1
            else Rly7 = State endif
        case 8
            if State >= 2 then Rly8 = Rly8 ^ 1
            else Rly8 = State endif
        case 9
            if State >= 2 then Rly9 = Rly9 ^ 1
            else Rly9 = State endif
        case 10
            if State >= 2 then Rly10 = Rly10 ^ 1
            else Rly10 = State endif
        case 11
            if State >= 2 then Rly11 = Rly11 ^ 1
            else Rly11 = State endif
        case 12
            if State >= 2 then Rly12 = Rly12 ^ 1
            else Rly12 = State endif
        case 13
            if State >= 2 then Rly13 = Rly13 ^ 1
            else Rly13 = State endif
        case 14
            if State >= 2 then Rly14 = Rly14 ^ 1
            else Rly14 = State endif
        case 15
            if State >= 2 then Rly15 = Rly15 ^ 1
            else Rly15 = State endif
        case 16
            if State >= 2 then Rly16 = Rly16 ^ 1
            else Rly16 = State endif
        case 17
            if State >= 2 then Rly17 = Rly17 ^ 1
            else Rly17 = State endif
        case 18
            if State >= 2 then Rly18 = Rly18 ^ 1
            else Rly18 = State endif
        case 19
            if State >= 2 then Rly19 = Rly19 ^ 1
            else Rly19 = State endif
        case 20
            if State >= 2 then Rly20 = Rly20 ^ 1
            else Rly20 = State endif
        case 21
            if State >= 2 then Rly21 = Rly21 ^ 1
            else Rly21 = State endif
        case 22
            if State >= 2 then Rly22 = Rly22 ^ 1
            else Rly22 = State endif
        case 23
            if State >= 2 then Rly23 = Rly23 ^ 1
            else Rly23 = State endif
        case 24
            if State >= 2 then Rly24 = Rly24 ^ 1
            else Rly24 = State endif
        case 25
            if State >= 2 then Rly25 = Rly25 ^ 1
            else Rly25 = State endif
        case 26
            if State >= 2 then Rly26 = Rly26 ^ 1
            else Rly26 = State endif
        case 27
            if State >= 2 then Rly27 = Rly27 ^ 1
            else Rly27 = State endif
        case 28
            if State >= 2 then Rly28 = Rly28 ^ 1
            else Rly28 = State endif
        case 29
            if State >= 2 then Rly29 = Rly29 ^ 1
            else Rly29 = State endif
        case 30
            if State >= 2 then Rly30 = Rly30 ^ 1
            else Rly30 = State endif
        case 31
            if State >= 2 then Rly31 = Rly31 ^ 1
            else Rly31 = State endif
        case 32
            if State >= 2 then Rly32 = Rly32 ^ 1
            else Rly32 = State endif
        else App_Message="Invalid relay id: " ~ RelayID
    endselect
    return
endfunction
function int8 GetRelay(int32 RelayID)           ; returns the current status of a specific relay 0=off, 1=on
    select RelayID
        case 1  if Rly1  == off then return 0 else return 1 endif
        case 2  if Rly2  == off then return 0 else return 1 endif
        case 3  if Rly3  == off then return 0 else return 1 endif
        case 4  if Rly4  == off then return 0 else return 1 endif
        case 5  if Rly5  == off then return 0 else return 1 endif
        case 6  if Rly6  == off then return 0 else return 1 endif
        case 7  if Rly7  == off then return 0 else return 1 endif
        case 8  if Rly8  == off then return 0 else return 1 endif
        case 9  if Rly9  == off then return 0 else return 1 endif
        case 10 if Rly10 == off then return 0 else return 1 endif
        case 11 if Rly11 == off then return 0 else return 1 endif
        case 12 if Rly12 == off then return 0 else return 1 endif
        case 13 if Rly13 == off then return 0 else return 1 endif
        case 14 if Rly14 == off then return 0 else return 1 endif
        case 15 if Rly15 == off then return 0 else return 1 endif
        case 16 if Rly16 == off then return 0 else return 1 endif
        case 17 if Rly17 == off then return 0 else return 1 endif
        case 18 if Rly18 == off then return 0 else return 1 endif
        case 19 if Rly19 == off then return 0 else return 1 endif
        case 20 if Rly20 == off then return 0 else return 1 endif
        case 21 if Rly21 == off then return 0 else return 1 endif
        case 22 if Rly22 == off then return 0 else return 1 endif
        case 23 if Rly23 == off then return 0 else return 1 endif
        case 24 if Rly24 == off then return 0 else return 1 endif
        case 25 if Rly25 == off then return 0 else return 1 endif
        case 26 if Rly26 == off then return 0 else return 1 endif
        case 27 if Rly27 == off then return 0 else return 1 endif
        case 28 if Rly28 == off then return 0 else return 1 endif
        case 29 if Rly29 == off then return 0 else return 1 endif
        case 30 if Rly30 == off then return 0 else return 1 endif
        case 31 if Rly31 == off then return 0 else return 1 endif
        case 32 if Rly32 == off then return 0 else return 1 endif
        else App_Message="Invalid realy ID"
    endselect
    return 0
endfunction

function InputsStart()                                                      ; start threads for physical & virtual input buttons
    App_Message="InputsStart"
    ; start all input threads for multi handling
    threadstart Input1IOCtr
    threadstart Input2IOCtr
    threadstart Input3IOCtr
    threadstart Input4IOCtr
    threadstart Input5IOCtr
    threadstart Input6IOCtr
    threadstart Input7IOCtr
    threadstart Input8IOCtr

    threadstart InputWeb

    select system.ModuleID                          ; start only needed physical input threads
        case 30 ;"dS3484"
            threadstart Input1
            threadstart Input2
            threadstart Input3
            threadstart Input4
            threadstart Input5
            threadstart Input6
            threadstart Input7
            threadstart Input8

            threadstart Input1off
            threadstart Input2off
            threadstart Input3off
            threadstart Input4off
            threadstart Input5off
            threadstart Input6off
            threadstart Input7off
            threadstart Input8off
        case 31 ;"dS1242"
            threadstart Input1
            threadstart Input2
            threadstart Input3
            threadstart Input4

            threadstart Input1off
            threadstart Input2off
            threadstart Input3off
            threadstart Input4off
        case 34 ;"dS2824"
            threadstart Input1
            threadstart Input2
            threadstart Input3
            threadstart Input4
            threadstart Input5
            threadstart Input6
            threadstart Input7
            threadstart Input8

            threadstart Input1off
            threadstart Input2off
            threadstart Input3off
            threadstart Input4off
            threadstart Input5off
            threadstart Input6off
            threadstart Input7off
            threadstart Input8off
        case 35 ;"dS378"
            threadstart Input1
            threadstart Input2
            threadstart Input3
            threadstart Input4
            threadstart Input5
            threadstart Input6
            threadstart Input7

            threadstart Input1off
            threadstart Input2off
            threadstart Input3off
            threadstart Input4off
            threadstart Input5off
            threadstart Input6off
            threadstart Input7off
        case 36 ;"TCP184"
            threadstart Input1
            threadstart Input2
            threadstart Input3
            threadstart Input4
            threadstart Input5
            threadstart Input6
            threadstart Input7
            threadstart Input8

            threadstart Input1off
            threadstart Input2off
            threadstart Input3off
            threadstart Input4off
            threadstart Input5off
            threadstart Input6off
            threadstart Input7off
            threadstart Input8off
    endselect
    return
endfunction
function InputHandler(int32 InpID, int32 Clicks)                            ; handles inputs based on defined input type
    App_Message="InputHandler"
    int8 InpType
    string IDstring[NAMESIZE]

    if App_EnableAutoIO == 1 then     ; auto process input types
        AutoInputHandler(InpID, Clicks)
        return
    endif

    InpType = GetIOType(InpID)  ; get the input type defined for this input
    if InpType == 4 then    ;Motion Sensor
        MotionSensorHandler(InpID, Clicks)
    else
        select InpID
            case 1 IDstring = App_IOSet1
            case 2 IDstring = App_IOSet2
            case 3 IDstring = App_IOSet3
            case 4 IDstring = App_IOSet4
            case 5 IDstring = App_IOSet5
            case 6 IDstring = App_IOSet6
            case 7 IDstring = App_IOSet7
            case 8 IDstring = App_IOSet8
         endselect
         StringInputHandler(IDstring, InpType, Clicks, InpID)
         endif
    endif          
    return
endfunction
function AutoInputHandler(int32 InpID, int32 Clicks)                        ; handles inputs dynamically based on defined # lights & # shutters
    App_Message="AutoInputHandler"
    int8 InpType
    int32 EntityID
    InpType = GetAutoInputType(InpID)
    EntityID = GetAutoEntityID(InpID, InpType)

    select InpType
        case 0  OtherClicksHandler(EntityID, Clicks)
        case 1  LightClicksHandler(EntityID, Clicks)
        case 2  ShutterClicksHandler(EntityID, Clicks, InpID)
        case 3  SocketClicksHandler(EntityID, Clicks)
        case 4  MotionSensorHandler(EntityID, Clicks)
        else App_Message="Invalid input type: " ~ InpType
    endselect   
    return
endfunction  
function StringInputHandler(string IDstring, int8 InpType, int32 Clicks, int32 InpID)    ; handles action based on given IDString (CSV string of IDs), input type and number of clicks (InpType: 1=Light, 2=Shutter, 3=Socket)
    App_Message="StringInputHandler"
    int32 idx
    int32 EntityID

    idx = 0
    EntityID = 0
    do while idx <= IDstring.Length             ; while idx is lower then the string length check if next characters are a number
        EntityID = IDstring.GetNumAscii(idx)
        if EntityID > 0 then                    ; if next characters are a number process this number
            if InpType == 1 then LightClicksHandler(EntityID, Clicks)
            elseif InpType == 2 then 
                if ShutterClicksHandler(EntityID, Clicks, InpID) == 1 then
                    idx = IDstring.Length + 1 endif ; ShutterClicksHandler returns 1 in case it is a raffstore which changes it's angle                                          ; this works only for the first inputID
            elseif InpType == 3 then SocketClicksHandler(EntityID, Clicks)
            else App_Message="Unhandled InpType: " ~ InpType
            endif
        endif        
        idx = idx + 1
    loop
    return
endfunction

function LightClicksHandler(int32 LightID, int32 Clicks)        ; handles all multiclicks related to lights
    App_InpType="Light"   
    select Clicks
        case 1  App_Message="toggle light" SetLight(LightID,2) 
        case 2  App_Message="enable ALL lights" ; on this controller
            for LightID = 1 to App_Lights
                SetLight(LightID,1)
            next
        case 3  App_Message="disable ALL lights" ; on this controller
            for LightID = 1 to App_Lights
                SetLight(LightID,0)
            next
        case 101 App_Message="enable single light"     ; physically nobody will be able to click this, but used for internal handling
            SetLight(LightID,1)
        case 102 App_Message="disable single light"     ; physically nobody will be able to click this, but used for internal handling
            SetLight(LightID,0)
        else App_Message="Unhandled click count"
    endselect
    return
endfunction
function int8 ShutterClicksHandler(int32 ShutterID, int32 Clicks, int32 InpID)    ; handles all multiclicks related to shutters
    App_InpType="Shutter"   
    
    select Clicks
        case 1  App_Message="open shutter"
            if App_ShutterStates[ShutterID-1] == 0 then App_ShutterTLevels[ShutterID-1] = 100  ; if shutter does not move currently, open it ;100 = fully open
            else                                        ; if shutter moves (independently of open/close) stop it
                App_ShutterTLevels[ShutterID-1] = App_ShutterCLevels[ShutterID-1] endif ; set the target level to current level for stopping by thread
            if App_IOActive[InpID-1] == 1 and GetShutterType(ShutterID) == 2 then       ; change the angle of a raffstore (while I/O is still pressed)
                App_RaffstoreIOs[ShutterID-1] = InpID
                RaffstoreStartThread(ShutterID)
                return 1
            else ShutterStartThread(ShutterID) endif                                    ; start shutter thread for any shutter type        
        case 2  App_Message="close shutter"
            if App_ShutterStates[ShutterID-1] == 0 then App_ShutterTLevels[ShutterID-1] = 0  ; if shutter does not move currently close it ; 0 = fully closed                
            else                                        ; if shutter moves (independently of open/close) stop it
                App_ShutterTLevels[ShutterID-1] = App_ShutterCLevels[ShutterID-1] endif ; set the target level to current level for stopping by thread
            if App_IOActive[InpID-1] == 1 and GetShutterType(ShutterID) == 2 then       ; change the angle of a raffstore (while I/O is still pressed)
                App_RaffstoreIOs[ShutterID-1] = InpID
                RaffstoreStartThread(ShutterID)
                return 1
            else ShutterStartThread(ShutterID) endif                                    ; start shutter thread for any shutter type   
        case 3 App_Message="open ALL shutters" ; on this controller
            for ShutterID = 1 to App_Shutters
                App_ShutterTLevels[ShutterID-1] = 100
                ShutterStartThread(ShutterID)
            next
        case 4 App_Message="close ALL shutters" ; on this controller
            for ShutterID = 1 to App_Shutters
                App_ShutterTLevels[ShutterID-1] = 0
                ShutterStartThread(ShutterID)       ; start shutter thread only if needed
            next
        else App_Message="Unhandled click count"
    endselect
    return 0
endfunction
function SocketClicksHandler(int32 SocketID, int32 Clicks)      ; handles all multiclicks related to sockets
    App_InpType="Socket"   
    select Clicks
        case 1  App_Message="toggle socket" SetSocket(SocketID,2) 
        case 2  App_Message="enable ALL sockets" ; on this controller
            for SocketID = 1 to App_Sockets
                SetSocket(SocketID,1)
            next
        case 3  App_Message="disable ALL sockets" ; on this controller
            for SocketID = 1 to App_Sockets
                SetSocket(SocketID,0)
            next
        case 101 App_Message="enable socket"     ; physically nobody will be able to click this, but used for internal handling
            SetSocket(SocketID,1)
        case 102 App_Message="disable socket"     ; physically nobody will be able to click this, but used for internal handling
            SetSocket(SocketID,0)
        else App_Message="Unhandled click count"
    endselect
    return
endfunction
function OtherClicksHandler(int32 OtherID, int32 Clicks)        ; handles all multiclicks not related to anything else
    App_InpType="Other"
    select Clicks
        case 0 App_Message="Unhandled click count" ; dummy value (for syntax correctness)
        else App_Message="Unhandled click count"
    endselect
    return
endfunction
function MotionSensorHandler(int32 InpID, int32 Clicks)         ; handles all clicks related to motion sensor
    select InpID
        case 1 threadstart MotionHandler1
        case 2 threadstart MotionHandler2
        case 3 threadstart MotionHandler3
        case 4 threadstart MotionHandler4
        case 5 threadstart MotionHandler5
        case 6 threadstart MotionHandler6
        case 7 threadstart MotionHandler7
        case 8 threadstart MotionHandler8
    endselect
endfunction

function SetLight(int32 LightID, int32 Action)      ; Sets the state of a light (Action: 0=OFF; 1=ON; 2 or any other=Toggle)
    App_Message="SetLight: " ~ LightID
    int32 RelayID

    if LightID > App_Lights then
        App_Message="Unhandled LightID: " ~ LightID
        return
    endif
    
    RelayID=App_LightsOffset-(LightID-1)            ; calculate the corresponding relay id for light id
    if Action == 0 then SetRelay(RelayID, off)
    elseif Action == 1 then SetRelay(RelayID, on)
    else SetRelay(RelayID, 2) endif ; 2 or any other means toggle relay
    dScriptServerTrigger(81, LightID)               ; trigger refresh on the dScriptServer
    return      
endfunction
function SetSocket(int32 SocketID, int32 Action)    ; Sets the state of a Socket (Action: 1=ON; 2=OFF; 0 or any other=Toggle)
    App_Message="SetSocket: " ~ SocketID

    if SocketID > App_Sockets then
        App_Message="Unhandled SocketID: " ~ SocketID
        return
    endif
    
    int32 RelayID
    RelayID=App_PhysRelays-(SocketID-1)             ; calculate the corresponding relay id for socket id
    if Action == 1 then SetRelay(RelayID, on)
    elseif Action == 2 then SetRelay(RelayID, off)
    else SetRelay(RelayID, 3) endif ;3 means toggle relay
    dScriptServerTrigger(83, SocketID)              ; trigger refresh on the dScriptServer 
    return      
endfunction

function ShutterOpen(int32 ShutterID)           ; open the shutter
     App_Message="ShutterOpen: " ~ ShutterID
     if ShutterID > App_Shutters then
        App_Message="Unhandled ShutterID: " ~ ShutterID
        return
     endif
     App_ShutterStates[ShutterID-1] = 1
     ShutterID = ShutterID*2 ; replace ShutterID with ID of second realy of shutter
     SetRelay(ShutterID, off)
     SetRelay((ShutterID - 1), on)
     return       
endfunction
function ShutterClose(int32 ShutterID)          ; close the shutter - select which connection type is used
    if App_ShutterRelayCT == 2 then
        ShutterCloseParallel(ShutterID)
    else
        ShutterCloseRow(ShutterID)
    endif
endfunction
function ShutterCloseParallel(int32 ShutterID)  ; close the shutter (assumes one is for open; one relay for closing)
     App_Message="ShutterCloseParallel: " ~ ShutterID
     if ShutterID > App_Shutters then
        App_Message="Unhandled ShutterID: " ~ ShutterID
        return
     endif     
     App_ShutterStates[ShutterID-1] = 2
     ShutterID = ShutterID*2 ; replace ShutterID with ID of second realy of shutter
     SetRelay((ShutterID - 1), off)
     SetRelay(ShutterID, on)
     return
endfunction
function ShutterCloseRow(int32 ShutterID)       ; close the shutter (assumes one relay defines move/not move; the other one the drection - open or close)
     App_Message="ShutterCloseRow: " ~ ShutterID
     if ShutterID > App_Shutters then
        App_Message="Unhandled ShutterID: " ~ ShutterID
        return
     endif
     App_ShutterStates[ShutterID-1] = 2
     ShutterID = ShutterID*2 ; replace ShutterID with ID of second realy of shutter 
     SetRelay(ShutterID, on)        ;this relay defines direction
     SetRelay((ShutterID - 1), on)  ;this defines that shutter should move
     return
endfunction
function ShutterStop(int32 ShutterID)           ; stop the shutter   
    App_Message="ShutterStop: " ~ ShutterID
    if ShutterID > App_Shutters then
        App_Message="Unhandled ShutterID: " ~ ShutterID
        return
    endif
    App_ShutterStates[ShutterID-1] = 0
    ShutterID = ShutterID*2 ; replace ShutterID with ID of second realy of shutter    
    SetRelay((ShutterID - 1), off)
    SetRelay(ShutterID, off)
    return
endfunction
function ShutterMoveDirection(int32 ShutterID)  ; set the shutter moevement state based on target variable
    App_Message="ShutterMoveDirection: " ~ ShutterID
    ; it is very important to READ App_ShutterLevels[ShutterID-1] in the following statements only
    if App_ShutterTLevels[ShutterID-1] == App_ShutterCLevels[ShutterID-1] then ShutterStop(ShutterID) 
    elseif App_ShutterTLevels[ShutterID-1] > App_ShutterCLevels[ShutterID-1] then ShutterOpen(ShutterID)    ;100 = fully open;
    elseif App_ShutterTLevels[ShutterID-1] < App_ShutterCLevels[ShutterID-1] then ShutterClose(ShutterID)   ;0 = fully closed
    else 
        App_Message="Invalid shutter levels"
        ShutterStop(ShutterID)
    endif
    return
endfunction

function int8 GetShutterType(int32 ShutterID)               ; returns the currently defined type of a shutter ( 0 = auto; 1 = roller; 2 = raffstore; 3 = jealousy )
    select ShutterID
        case 1 return App_ShutterType1                  
        case 2 return App_ShutterType2                  
        case 3 return App_ShutterType3                  
        case 4 return App_ShutterType4                  
        case 5 return App_ShutterType5                  
        case 6 return App_ShutterType6                  
        case 7 return App_ShutterType7                  
        case 8 return App_ShutterType8                  
        case 9 return App_ShutterType9                  
        case 10 return App_ShutterType10                 
        case 11 return App_ShutterType11                 
        case 12 return App_ShutterType12                 
        case 13 return App_ShutterType13                 
        case 14 return App_ShutterType14                 
        case 15 return App_ShutterType15                 
        case 16 return App_ShutterType16
    endselect
endfunction
function ShutterStartThread(int32 ShutterID)                ; starts shutter thread, but only if not already running
    App_Message="ShutterStartThread"
    if App_ShutterStates[ShutterID-1] == 0 then
        select ShutterID
            case 1  threadstart MoveShutter1
            case 2  threadstart MoveShutter2
            case 3  threadstart MoveShutter3
            case 4  threadstart MoveShutter4
            case 5  threadstart MoveShutter5
            case 6  threadstart MoveShutter6
            case 7  threadstart MoveShutter7
            case 8  threadstart MoveShutter8
            case 9  threadstart MoveShutter9
            case 10 threadstart MoveShutter10
            case 11 threadstart MoveShutter11
            case 12 threadstart MoveShutter12
            case 13 threadstart MoveShutter13
            case 14 threadstart MoveShutter14
            case 15 threadstart MoveShutter15
            case 16 threadstart MoveShutter16
        endselect
    endif
    return
endfunction
function int32 ShutterGetClosingTime(int32 ShutterID)       ; returns the closing time for defined shutter based on shutter ID
    select ShutterID
        case 1  return App_ShutterCT1
        case 2  return App_ShutterCT2
        case 3  return App_ShutterCT3
        case 4  return App_ShutterCT4
        case 5  return App_ShutterCT5
        case 6  return App_ShutterCT6
        case 7  return App_ShutterCT7
        case 8  return App_ShutterCT8
        case 9  return App_ShutterCT9
        case 10 return App_ShutterCT10
        case 11 return App_ShutterCT11
        case 12 return App_ShutterCT12
        case 13 return App_ShutterCT13
        case 14 return App_ShutterCT14
        case 15 return App_ShutterCT15
        case 16 return App_ShutterCT16        
    endselect
    return 0  
endfunction
function ShutterMoveThreadX(int32 ShutterID)                ; function used by every MoveShutterX thread
    int32 ShutterCT   
    App_ShutterCLevels[ShutterID-1] = App_ShutterLevels[ShutterID-1] ; temporary working variable to prevent a lot of writes to eeprom
    ShutterCT = ShutterGetClosingTime(ShutterID)                     ; define closing time for door or window

    do while App_ShutterTLevels[ShutterID-1] != App_ShutterCLevels[ShutterID-1]
        if App_ShutterStates[ShutterID-1] == 0 then           ; currently stopped
            if App_ShutterTLevels[ShutterID-1] != App_ShutterCLevels[ShutterID-1] then
                ShutterMoveDirection(ShutterID) endif       ; if status is not correct and we are not moving we have to            
        elseif App_ShutterStates[ShutterID-1] == 1  then      ; currently opening
            if App_ShutterTLevels[ShutterID-1] < App_ShutterCLevels[ShutterID-1] then 
                ShutterMoveDirection(ShutterID)             ; if we are opening and the target is smaller than the current level we move into wrong direction
            else App_ShutterCLevels[ShutterID-1]+=1 endif     ; 100 = fully open
        elseif App_ShutterStates[ShutterID-1] == 2            ; currently closing
            if App_ShutterTLevels[ShutterID-1] > App_ShutterCLevels[ShutterID-1] then 
                ShutterMoveDirection(ShutterID)             ; if we are closing and the target is bigger than the current level we move into wrong direction
            else App_ShutterCLevels[ShutterID-1]-=1 endif     ; 0 = fully closed             
        endif       
        threadsleep (ShutterCT/100) ; sleep 1 percentage of closing
    loop
    
    ShutterStop(ShutterID)
    App_ShutterLevels[ShutterID-1] = App_ShutterCLevels[ShutterID-1] ; write the finished status back into eeprom
    dScriptServerTrigger(82, ShutterID)              ; trigger refresh on the dScriptServer
    return
endfunction
function RaffstoreStartThread(int32 ShutterID)              ; starts shutter thread, but only if not already running
    App_Message="RaffstoreStartThread"
    if App_ShutterStates[ShutterID-1] == 0 then
        select ShutterID
            case 1  threadstart MoveRaffstore1
            case 2  threadstart MoveRaffstore2
            case 3  threadstart MoveRaffstore3
            case 4  threadstart MoveRaffstore4
            case 5  threadstart MoveRaffstore5
            case 6  threadstart MoveRaffstore6
            case 7  threadstart MoveRaffstore7
            case 8  threadstart MoveRaffstore8
            case 9  threadstart MoveRaffstore9
            case 10 threadstart MoveRaffstore10
            case 11 threadstart MoveRaffstore11
            case 12 threadstart MoveRaffstore12
            case 13 threadstart MoveRaffstore13
            case 14 threadstart MoveRaffstore14
            case 15 threadstart MoveRaffstore15
            case 16 threadstart MoveRaffstore16
        endselect
    endif
    return
endfunction
function RaffstoreMoveThreadX(int32 ShutterID)              ; function used by every MoveRaffstoreX thread
    int8 InpID
    InpID = App_RaffstoreIOs[ShutterID-1]
    if InpID == 0 then 
        App_Message="Zero InputID"
        return
    endif
    ShutterStartThread(ShutterID)
    do while App_IOActive[InpID-1] == 1                     ; loop while input is active
        threadsleep 50
    loop
    App_ShutterTLevels[ShutterID-1] = App_ShutterCLevels[ShutterID-1]   ; set shutter target level to current one
    App_RaffstoreIOs[ShutterID-1] = 0
    return
endfunction

function int8 GetIOType(int32 InpID)                        ; return the currently defined IO type of a specific input (0 = Auto Type / UNKNOWN; 1 = Light; 2 = Shutter; 3 = Socket; 4 = Motion)
    select InpID
        case 1 return App_IOType1
        case 2 return App_IOType2
        case 3 return App_IOType3
        case 4 return App_IOType4
        case 5 return App_IOType5
        case 6 return App_IOType6
        case 7 return App_IOType7
        case 8 return App_IOType8
    endselect
endfunction
function int8 GetAutoInputType(int32 InpID)                 ; return the type a specific input is configured for via AutoInputType (0 = Auto Type / UNKNOWN; 1 = Light; 2 = Shutter; 3 = Socket; 4 = Motion)
    if InpID <= App_Lights then ; process lights
        return 1 ; = Light
    else
        int32 ShuttersOffset
        ShuttersOffset = 0
        if ( App_Lights // 2 ) == 1 and ( App_Shutters // 2 ) == 0 ShuttersOffset = 1  ; other button between light & shutter buttons exists
        if InpID == ( App_Lights + ShuttersOffset ) then ; other button between light & shutter buttons was pressed
            return 4 ; = Motion
        elseif InpID > ( App_Lights + App_Shutters + ShuttersOffset ) then ; other button after all light & shutter buttons was pressed
            return 4 ; = Motion
        endif
        return 2 ; = Shutter
    endif        
    return 0    ; = Unknown
endfunction
function int32 GetAutoEntityID(int32 InpID, int8 InpType)   ; return the entity ID for given inputID with given type
    select InpType
        case 0  return InpID                        ; 0 = Auto / UNKNOWN
        case 1  return InpID                        ; 1 = Light
        case 2                                      ; 2 = Shutter
                int32 ShuttersOffset
                ShuttersOffset = 0
                if ( App_Lights // 2 ) == 1 and ( App_Shutters // 2 ) == 0 ShuttersOffset = 1  ; other button between light & shutter buttons exists
                return (InpID - App_Lights - ShuttersOffset)
        case 3  return InpID                        ; 3 = Socket
        case 4  return GetIOMotionID(InpID)         ; 4 = Motion
        else    return 1                            ; UNKNOWN
    endselect 
endfunction

function int32 GetMotionIDIO(int32 MotionID)                ; return the I/O id for a specific motion sensor ID
    if MotionID > App_Motions then 
        App_Message="Unhandled MotionID: " ~ MotionID
        return 0
    endif

    int8 MotionsCount
    int32 InpID
    
    MotionsCount = 0      
    for InpID = 1 to 8           
        select InpID                                        ; count +1 if input type == 4 (motion)
            case 1 if App_IOType1 == 4 MotionsCount+=1
            case 2 if App_IOType2 == 4 MotionsCount+=1
            case 3 if App_IOType3 == 4 MotionsCount+=1
            case 4 if App_IOType4 == 4 MotionsCount+=1
            case 5 if App_IOType5 == 4 MotionsCount+=1
            case 6 if App_IOType6 == 4 MotionsCount+=1
            case 7 if App_IOType7 == 4 MotionsCount+=1
            case 8 if App_IOType8 == 4 MotionsCount+=1
        endselect

        if MotionsCount == MotionID then
            return InpID
        endif
    next
    return 0
endfunction
function int32 GetIOMotionID(int32 InpID)                   ; return the Motion Sensor ID for a specific I/O id 
    int32 MotionID
    int32 IOid
    
    MotionID = 0
    IOid = 0
    for IOid = 1 to InpID           
        select IOid                                        ; count +1 if input type == 4 (motion)
            case 1 if App_IOType1 == 4 MotionID+=1
            case 2 if App_IOType2 == 4 MotionID+=1
            case 3 if App_IOType3 == 4 MotionID+=1
            case 4 if App_IOType4 == 4 MotionID+=1
            case 5 if App_IOType5 == 4 MotionID+=1
            case 6 if App_IOType6 == 4 MotionID+=1
            case 7 if App_IOType7 == 4 MotionID+=1
            case 8 if App_IOType8 == 4 MotionID+=1
        endselect
    next
    return MotionID
endfunction
function MotionThreadX(int32 MotionID)             ; thread to handle motion detection and turn lights on/off correspondingly
    App_Message="MotionThreadX"
    string IDstring[NAMESIZE]
    int32 InpID

    InpID = GetMotionIDIO(MotionID)         ; ghet the inputID for motion sensor   
    select InpID                            ; get input string for InputID
        case 1 IDstring = App_IOSet1
        case 2 IDstring = App_IOSet2
        case 3 IDstring = App_IOSet3
        case 4 IDstring = App_IOSet4
        case 5 IDstring = App_IOSet5
        case 6 IDstring = App_IOSet6
        case 7 IDstring = App_IOSet7
        case 8 IDstring = App_IOSet8
    endselect

    App_Message="Enable Motion Lights: " ~ MotionID
    StringInputHandler(IDstring, 1, 101, 0)    ; 1 = Light as we want to control lights | 101 = dummy click count to turn on light | 0 = dummy value for internal input
    dScriptServerTrigger(84, MotionID)      ; trigger refresh on the dScriptServer
    
    do while App_IOActive[InpID-1]          ; wait for input to be inactive
        threadsleep 100
    loop

    App_Message="Disable Motion Lights: " ~ MotionID
    StringInputHandler(IDstring, 1, 102, 0)    ; 1 = Light as we want to control lights | 102 = dummy click count to turn off light | 0 = dummy value for internal input
    dScriptServerTrigger(84, MotionID)      ; trigger refresh on the dScriptServer
    return
endfunction

function Binary()                               ; processes incoming / outgpoing binary tcp/ip traffic
    if tcpLength > 0 then 
        NonceIn = Nonce                         ; not using AES, so just make it equal do BinaryDo will work OK.
        BinaryDo()                              ; actually execute the binary command
        if(tcpLength) tcpip.Write(tcpOutBuf, tcpLength)
    endif
    return
endfunction     
function BinaryAES()                            ; processes incoming / outgpoing AES encrypted binary tcp/ip traffic
    if tcpLength > 31 then                      ; needs to be at least 32 bytes 
        aes.decrypt(tcpInBuf, 16)
        x = 12
        NonceIn = tcpInBuf.GetNumBinary(x, 4)                   
        for x = 0 to 15 
            tcpOutBuf[x] = 0
        next
        BinaryDo()                              ; actually execute the binary command
        aes.encrypt(tcpOutBuf, 16)
        tcpip.Write(tcpOutBuf, 32)
    endif
    return
endfunction
function BinaryDo()                             ; function interpreting the binary TCP/IP query and returning corresponding values / actions
    tcpLength = 0
    select tcpInBuf[0]
        case 0x30   BinaryGetStatus()           ; decimal 48
        case 0x31   BinarySetRelay()            ; decimal 49
        case 0x32   BinarySetOutput()           ; decimal 50
        case 0x33   BinaryGetRelay()            ; decimal 51
        case 0x34   BinaryGetInput()            ; decimal 52
        case 0x35   BinaryGetAnalogue()         ; decimal 53
        case 0x36   BinaryGetCounter()          ; decimal 54
        case 0x40   BinarySetLight()            ; decimal 64
        case 0x41   BinarySetShutter()          ; decimal 65
        case 0x42   BinarySetSocket()           ; decimal 66
        case 0x50   BinaryGetConfig()           ; decimal 80
        case 0x51   BinaryGetLight()            ; decimal 81
        case 0x52   BinaryGetShutter()          ; decimal 82
        case 0x53   BinaryGetSocket()           ; decimal 83
        case 0x54   BinaryGetMotion()           ; decimal 84
        else App_Message="Invalid binary cmd: " ~ tcpInBuf[0]
    endselect
    return
endfunction 
function BinaryGetStatus()                      ; GS, Get Status - returns 8 bytes.
    tcpOutBuf[0] = system.ModuleID      ; ( 30=dS3484; 31=dS1242; 34=dS2824; 35=dS378; 36=TCP184 )
    tcpOutBuf[1] = VerMajor             ; Firmware version - major
    tcpOutBuf[2] = VerMinor             ; Firmware version - minor
    tcpOutBuf[3] = AppVerMajor          ; Application Firmware version - major
    tcpOutBuf[4] = AppVerMinor          ; Application Firmware version - minor
    tcpOutBuf[5] = Volts                ; Volts*10, 125 = 12.5v
    tcpOutBuf[6] = BrdTemp>>8           ; internal temperature*10, high byte
    tcpOutBuf[7] = BrdTemp&255          ; internal temperature*10, low byte, (combined to 16 bits, 267 = 26.7 degrees C)
    Nonce = system.Random
    tcpOutBuf[12] = Nonce >> 24
    tcpOutBuf[13] = Nonce >> 16         ; insert Nonce - just in case we are being called by AES mode 
    tcpOutBuf[14] = Nonce >> 8
    tcpOutBuf[15] = Nonce
    tcpLength = 8
    return
endfunction
function BinarySetRelay()                       ; SR, Set Relay - relay num, state, pulse time/state (4 bytes), total 7 byte command
    x = 3                                           ; used as a temporary index (originally used with value PulseTime)
    x = tcpInBuf.GetNumBinary(x, 4)                 ; originally got 4 byte pulse time ( no longer supported)
    select tcpInBuf[1]
        case 1 to 32
            if Nonce == NonceIn then                ; process command only Nonce counting is correct
                SetRelay(tcpInBuf[1],tcpInBuf[2])   ; set the relay 
                tcpOutBuf[0] = 0 endif              ; ACK
        else tcpOutBuf[0] = tcpInBuf[1]             ; NACK, unknown relay number, send relay number as NACK                 
    endselect
    Nonce = system.Random
    tcpOutBuf[12] = Nonce >> 24
    tcpOutBuf[13] = Nonce >> 16                     ; insert Nonce - just in case we are being called by AES mode 
    tcpOutBuf[14] = Nonce >> 8
    tcpOutBuf[15] = Nonce
    tcpLength = 1
    return
endfunction
function BinarySetOutput()                      ; SO, Set Output - output num, state, total 3 byte command
    select tcpInBuf[1]
        case 1 to 8
            if Nonce == NonceIn then                ; process command only Nonce counting is correct 
                SetIO(tcpInBuf[1], tcpInBuf[2])     ; set the output    
                tcpOutBuf[0] = 0 endif              ; ACK
        else tcpOutBuf[0] = tcpInBuf[1]             ; NACK, unknown I/O number, send number as NACK                 
    endselect
    Nonce = system.Random
    tcpOutBuf[12] = Nonce >> 24
    tcpOutBuf[13] = Nonce >> 16                     ; insert Nonce - just in case we are being called by AES mode 
    tcpOutBuf[14] = Nonce >> 8
    tcpOutBuf[15] = Nonce
    tcpLength = 1
    return
endfunction
function BinaryGetRelay()                       ; GR, Get Relay - 1st is requested relay, 2nd,4rd,4th are packed relays,
    tcpOutBuf[0] = GetRelay(tcpInBuf[1])
    tcpOutBuf[1] = 0
    tcpOutBuf[2] = 0
    tcpOutBuf[3] = 0
    tcpOutBuf[4] = 0            
    if Rly1==on then tcpOutBuf[4] = tcpOutBuf[4] | 0x01 endif
    if Rly2==on then tcpOutBuf[4] = tcpOutBuf[4] | 0x02 endif
    if Rly3==on then tcpOutBuf[4] = tcpOutBuf[4] | 0x04 endif
    if Rly4==on then tcpOutBuf[4] = tcpOutBuf[4] | 0x08 endif
    if Rly5==on then tcpOutBuf[4] = tcpOutBuf[4] | 0x10 endif
    if Rly6==on then tcpOutBuf[4] = tcpOutBuf[4] | 0x20 endif
    if Rly7==on then tcpOutBuf[4] = tcpOutBuf[4] | 0x40 endif
    if Rly8==on then tcpOutBuf[4] = tcpOutBuf[4] | 0x80 endif
    if Rly9==on then tcpOutBuf[3] = tcpOutBuf[3] | 0x01 endif
    if Rly10==on then tcpOutBuf[3] = tcpOutBuf[3] | 0x02 endif
    if Rly11==on then tcpOutBuf[3] = tcpOutBuf[3] | 0x04 endif
    if Rly12==on then tcpOutBuf[3] = tcpOutBuf[3] | 0x08 endif
    if Rly13==on then tcpOutBuf[3] = tcpOutBuf[3] | 0x10 endif
    if Rly14==on then tcpOutBuf[3] = tcpOutBuf[3] | 0x20 endif
    if Rly15==on then tcpOutBuf[3] = tcpOutBuf[3] | 0x40 endif
    if Rly16==on then tcpOutBuf[3] = tcpOutBuf[3] | 0x80 endif                  
    if Rly17==on then tcpOutBuf[2] = tcpOutBuf[2] | 0x01 endif
    if Rly18==on then tcpOutBuf[2] = tcpOutBuf[2] | 0x02 endif
    if Rly19==on then tcpOutBuf[2] = tcpOutBuf[2] | 0x04 endif
    if Rly20==on then tcpOutBuf[2] = tcpOutBuf[2] | 0x08 endif
    if Rly21==on then tcpOutBuf[2] = tcpOutBuf[2] | 0x10 endif
    if Rly22==on then tcpOutBuf[2] = tcpOutBuf[2] | 0x20 endif
    if Rly23==on then tcpOutBuf[2] = tcpOutBuf[2] | 0x40 endif
    if Rly24==on then tcpOutBuf[2] = tcpOutBuf[2] | 0x80 endif          
    if Rly25==on then tcpOutBuf[1] = tcpOutBuf[1] | 0x01 endif
    if Rly26==on then tcpOutBuf[1] = tcpOutBuf[1] | 0x02 endif
    if Rly27==on then tcpOutBuf[1] = tcpOutBuf[1] | 0x04 endif
    if Rly28==on then tcpOutBuf[1] = tcpOutBuf[1] | 0x08 endif
    if Rly29==on then tcpOutBuf[1] = tcpOutBuf[1] | 0x10 endif
    if Rly30==on then tcpOutBuf[1] = tcpOutBuf[1] | 0x20 endif
    if Rly31==on then tcpOutBuf[1] = tcpOutBuf[1] | 0x40 endif
    if Rly32==on then tcpOutBuf[1] = tcpOutBuf[1] | 0x80 endif
    tcpLength = 5
    return
endfunction
function BinaryGetInput()                       ; GI, Get Input - 1st is requested input, 2nd is packed inputs
    tcpOutBuf[0] = 0
    tcpOutBuf[1] = 0
    select tcpInBuf[1]
        case 1  if IO1==on tcpOutBuf[0] = 1 
        case 2  if IO2==on tcpOutBuf[0] = 1 
        case 3  if IO3==on tcpOutBuf[0] = 1 
        case 4  if IO4==on tcpOutBuf[0] = 1 
        case 5  if IO5==on tcpOutBuf[0] = 1 
        case 6  if IO6==on tcpOutBuf[0] = 1 
        case 7  if IO7==on tcpOutBuf[0] = 1 
        case 8  if IO8==on tcpOutBuf[0] = 1 
    endselect
    if IO1==on then tcpOutBuf[1] = tcpOutBuf[1] | 0x01 endif
    if IO2==on then tcpOutBuf[1] = tcpOutBuf[1] | 0x02 endif
    if IO3==on then tcpOutBuf[1] = tcpOutBuf[1] | 0x04 endif
    if IO4==on then tcpOutBuf[1] = tcpOutBuf[1] | 0x08 endif
    if IO5==on then tcpOutBuf[1] = tcpOutBuf[1] | 0x10 endif
    if IO6==on then tcpOutBuf[1] = tcpOutBuf[1] | 0x20 endif
    if IO7==on then tcpOutBuf[1] = tcpOutBuf[1] | 0x40 endif
    if IO8==on then tcpOutBuf[1] = tcpOutBuf[1] | 0x80 endif
    tcpLength = 2
    return
endfunction
function BinaryGetAnalogue()                    ; GA, Get Analog - 1st is high byte, 2nd is low byte of input - returns all 8 analog inputs (some may actually be digital)
    for x=0 to 7                    ; initialize an empty tcpOutBuf of 16 bytes 
        tcpOutBuf[(x*2)] = 0>>8
        tcpOutBuf[((x*2)+1)] = 0&255
    next 
    tcpLength = 16                  ; lenght reply is always 16 bytes

    ; fill return based on module and its connectors ;( 30=dS3484; 31=dS1242; 34=dS2824; 35=dS378; 36=TCP184 )
    if system.ModuleID == 30 or system.ModuleID == 31 then      ;( 30=dS3484; 31=dS1242 )
        x = AD1                 ; returns first 2 analog inputs
        tcpOutBuf[0] = x>>8           
        tcpOutBuf[1] = x&255  
        x = AD2
        tcpOutBuf[2] = x>>8
        tcpOutBuf[3] = x&255
    endif
    if system.ModuleID == 30 then                               ;( 30=dS3484 )
        x = AD3                 ; returns analog inputs 3 & 4
        tcpOutBuf[4] = x>>8
        tcpOutBuf[5] = x&255  
        x = AD4
        tcpOutBuf[6] = x>>8
        tcpOutBuf[7] = x&255  
    endif     
    if system.ModuleID == 34 or system.ModuleID == 35 or system.ModuleID == 36 then ;( 34=dS2824; 35=dS378; 36=TCP184 )
        tcpOutBuf[0] = IO1>>8   ; returns first 7 analog inputs (some may actually be digital)
        tcpOutBuf[1] = IO1&255  
        tcpOutBuf[2] = IO2>>8
        tcpOutBuf[3] = IO2&255  
        tcpOutBuf[4] = IO3>>8
        tcpOutBuf[5] = IO3&255  
        tcpOutBuf[6] = IO4>>8
        tcpOutBuf[7] = IO4&255  
        tcpOutBuf[8] = IO5>>8
        tcpOutBuf[9] = IO5&255  
        tcpOutBuf[10] = IO6>>8
        tcpOutBuf[11] = IO6&255     
        tcpOutBuf[12] = IO7>>8
        tcpOutBuf[13] = IO7&255
    endif
    if system.ModuleID == 34 or system.ModuleID == 36 then  ;( 34=dS2824; 36=TCP184 )
        tcpOutBuf[14] = IO8>>8  ; returns the 9 analog input (some may actually be digital)
        tcpOutBuf[15] = IO8&255
    endif
    return
endfunction
function BinaryGetCounter()                     ; GC, Get Counter - Counter num, 2 byte command returning 8 bytes
    tcpOutBuf[0] = 0>>24                      ; sorry - this case is just a dummy to ensure backwards compatibility
    tcpOutBuf[1] = 0>>16                      ; it will always return 0 for all counters
    tcpOutBuf[2] = 0>>8
    tcpOutBuf[3] = 0&255              
    tcpOutBuf[4] = 0>>24
    tcpOutBuf[5] = 0>>16     
    tcpOutBuf[6] = 0>>8
    tcpOutBuf[7] = 0&255     
    tcpLength = 8
    return
endfunction
function BinarySetLight()                       ; SL, Set Light - light id, state, total 3 byte command
    select tcpInBuf[1]
        case 1 to App_Lights
            if Nonce == NonceIn then                ; process command only Nonce counting is correct 
                SetLight(tcpInBuf[1], tcpInBuf[2])  ; process command    
                tcpOutBuf[0] = 0 endif              ; ACK
        else tcpOutBuf[0] = tcpInBuf[1]             ; NACK, unknown light id, send number as NACK                 
    endselect
    Nonce = system.Random
    tcpOutBuf[12] = Nonce >> 24
    tcpOutBuf[13] = Nonce >> 16                     ; insert Nonce - just in case we are being called by AES mode 
    tcpOutBuf[14] = Nonce >> 8
    tcpOutBuf[15] = Nonce
    tcpLength = 1
    return
endfunction
function BinarySetShutter()                     ; SH, Set Shutter - shutter id, state, total 3 byte command
    select tcpInBuf[1]
        case 1 to App_Shutters          
            if Nonce == NonceIn then    ; process command only Nonce counting is correct   
                if tcpInBuf[2] == 255 then
                     App_ShutterTLevels[tcpInBuf[1]-1] = App_ShutterCLevels[tcpInBuf[1]-1]  ; set shutter target state to current state (and cause a stop with this)
                elseif tcpInBuf[2] > 100 then App_ShutterTLevels[tcpInBuf[1]-1] = 100       ; set the shutter target state to fully open (100)
                elseif tcpInBuf[2] < 0 then App_ShutterTLevels[tcpInBuf[1]-1] = 0           ; set the shutter target state to fully closed (0)
                else App_ShutterTLevels[tcpInBuf[1]-1] = tcpInBuf[2] endif                  ; take the shutter target state from given value
                ShutterStartThread(tcpInBuf[1])                                             ; start shutter thread only if needed
                tcpOutBuf[0] = 0 endif      ; ACK
            else tcpOutBuf[0] = tcpInBuf[1] ; NACK, unknown I/O number, send number as NACK                
    endselect
    Nonce = system.Random
    tcpOutBuf[12] = Nonce >> 24
    tcpOutBuf[13] = Nonce >> 16         ; insert Nonce - just in case we are being called by AES mode 
    tcpOutBuf[14] = Nonce >> 8
    tcpOutBuf[15] = Nonce
    tcpLength = 1
    return
endfunction
function BinarySetSocket()                      ; SC, Set Socket - socket id, state, total 3 byte command
    if App_Sockets == 0 then tcpOutBuf[0] = tcpInBuf[1]
    else
        select tcpInBuf[1]
            case 1 to App_Sockets
                select tcpInBuf[2]                      ; correct tcpInBuf2 to match SetSocket function
                    case 0x00 tcpInBuf[2] = 1           ; 0=off (in request) 2=off (in SetSocket) -> do exactly the opposite since sockets are usucally NC instead of NO
                    case 0x01 tcpInBuf[2] = 2           ; 1=on (in request) 1=on (in SetSocket) -> do exactly the opposite since sockets are usucally NC instead of NO
                    else tcpInBuf[2] = 0                ; toggle
                endselect
                if Nonce == NonceIn then                ; process command only Nonce counting is correct 
                    SetSocket(tcpInBuf[1], tcpInBuf[2]) ; process command    
                    tcpOutBuf[0] = 0 endif              ; ACK
            else tcpOutBuf[0] = tcpInBuf[1]             ; NACK, unknown light id, send number as NACK                 
        endselect
    endif
    Nonce = system.Random
    tcpOutBuf[12] = Nonce >> 24
    tcpOutBuf[13] = Nonce >> 16                     ; insert Nonce - just in case we are being called by AES mode 
    tcpOutBuf[14] = Nonce >> 8
    tcpOutBuf[15] = Nonce
    tcpLength = 1
    return
endfunction
function BinaryGetConfig()                      ; GO, Get Config - returns 11 bytes
    tcpOutBuf[0] = System_MAC[0]        ; MAC address of the system - byte 1
    tcpOutBuf[1] = System_MAC[1]        ; MAC address of the system - byte 2
    tcpOutBuf[2] = System_MAC[2]        ; MAC address of the system - byte 3
    tcpOutBuf[3] = System_MAC[3]        ; MAC address of the system - byte 4
    tcpOutBuf[4] = System_MAC[4]        ; MAC address of the system - byte 5
    tcpOutBuf[5] = System_MAC[5]        ; MAC address of the system - byte 6
    tcpOutBuf[6] = App_PhysRelays       ; number of physical relays (depends on the module)
    tcpOutBuf[7] = App_Lights           ; number of lights connected to relays
    tcpOutBuf[8] = App_Shutters         ; number of shutters connected to relays
    tcpOutBuf[9] = App_Sockets          ; number of sockets connected to relays
    tcpOutBuf[10] = App_Motions          ; number of motion sensors connected to relays
    tcpLength = 11
    return
endfunction
function BinaryGetLight()                       ; GL, Get Light - returns 1 byte
    int8 RelayID
    RelayID=App_LightsOffset-(tcpInBuf[1]-1)    ; replace light id with rleay id
    tcpOutBuf[0] = GetRelay(RelayID)
    tcpLength = 1
    return
endfunction
function BinaryGetShutter()                     ; GH, Get Shutter - returns 2 bytes
    tcpOutBuf[1] = App_ShutterStates[tcpInBuf[1]-1]
    if App_ShutterStates[tcpInBuf[1]-1] == 0 then           ; currently stopped
        tcpOutBuf[0] = App_ShutterLevels[tcpInBuf[1]-1]     ; use the 'Levels' value which is used for restoring, too
    else tcpOutBuf[0] = App_ShutterCLevels[tcpInBuf[1]-1]   ; use the 'CLevels' value which is used for correct moving
    endif
    tcpLength = 2
    return
endfunction
function BinaryGetSocket()                      ; GK, Get Socket - returns 1 byte
    int8 RelayID
    RelayID=App_PhysRelays-(tcpInBuf[1]-1)      ; replace socket id with rleay id
    tcpOutBuf[0] = GetRelay(RelayID)            
    if tcpOutBuf[0] == 0 then tcpOutBuf[0] = 1       ; sockets are usually connected to NC instead of NO - so invert here
    elseif tcpOutBuf[0] == 1 tcpOutBuf[0] = 0 endif
    tcpLength = 1
    return
endfunction
function BinaryGetMotion()                      ; GM, Get Motion - returns 1 byte
    int32 InpID                                 ; the input ID assigned to tcpInBuf given MotionID
    InpID = GetMotionIDIO(tcpInBuf[1])
    tcpOutBuf[0] = App_IOActive[InpID-1]
    tcpLength = 1
    return
endfunction

function UpdateAutoIO()                              ; update the IOTypes based on defined lights and shutters
    ;App_Message="UpdateAutoIO"
    if App_EnableAutoIO == 1 then
        int32 InpID        
        int8 InpType
        int32 EntityID
        for InpID = 1 to 8
            InpType = GetAutoInputType(InpID)
            EntityID = GetAutoEntityID(InpID, InpType)
            
            select InpID                                ; set the input type defined for this input
                case 1 
                    App_IOType1 = InpType
                    if InpType != 4 App_IOSet1 = "" ~ EntityID
                case 2 
                    App_IOType2 = InpType
                    if InpType != 4 App_IOSet2 = "" ~ EntityID
                case 3 
                    App_IOType3 = InpType
                    if InpType != 4 App_IOSet3 = "" ~ EntityID
                case 4 
                    App_IOType4 = InpType
                    if InpType != 4 App_IOSet4 = "" ~ EntityID
                case 5 
                    App_IOType5 = InpType
                    if InpType != 4 App_IOSet5 = "" ~ EntityID
                case 6 
                    App_IOType6 = InpType
                    if InpType != 4 App_IOSet6 = "" ~ EntityID
                case 7 
                    App_IOType7 = InpType
                    if InpType != 4 App_IOSet7 = "" ~ EntityID
                case 8 
                    App_IOType8 = InpType
                    if InpType != 4 App_IOSet8 = "" ~ EntityID
            endselect
        next
        UpdateMotions()
    endif
endfunction
function UpdateMotions()                             ; update the number of motion sensors connected
    int8 MotionsCount
    MotionsCount = 0    
    for x = 1 to 8           
        select x                                        ; count +1 if input type == 4 (motion)
            case 1 if App_IOType1 == 4 MotionsCount+=1
            case 2 if App_IOType2 == 4 MotionsCount+=1
            case 3 if App_IOType3 == 4 MotionsCount+=1
            case 4 if App_IOType4 == 4 MotionsCount+=1
            case 5 if App_IOType5 == 4 MotionsCount+=1
            case 6 if App_IOType6 == 4 MotionsCount+=1
            case 7 if App_IOType7 == 4 MotionsCount+=1
            case 8 if App_IOType8 == 4 MotionsCount+=1
        endselect
    next
    App_Motions = MotionsCount
endfunction

function dScriptServerTrigger(int8 cmdID, int8 objID)   ; trigger requests on status updates to dScriptServer
    ;App_Message="dScriptServerTrigger"
    string  clientBuf[2]                               ; all Get XXXXX commands in binary are two byte commands
    int32   clientLength                               ;   based on this we are able to trigger an update on any specific object that changed
    
    if App_dScriptServer[0] == 0 then           ; skip if no dScriptServer is defined
        ;App_Message="No dScriptServer"
        return 
    endif
    
    select cmdID
        case 0  					; hearbeat trigger to server
            ;App_Message="dScriptServerHeartbeat"
            clientBuf[0] = cmdID clientBuf[1] = 0
        case 48 ; decimal value for: GS, Get Status
            clientBuf[0] = cmdID clientBuf[1] = objID
        case 51 ; decimal value for: GR, Get Relay      ;TO-DO: call this function from SetRelay
            clientBuf[0] = cmdID clientBuf[1] = objID
        case 52 ; decimal value for: GI, Get Input      ;TO-DO: call this function from InputHandler
            clientBuf[0] = cmdID clientBuf[1] = objID
        case 53 ; decimal value for: GA, Get Analog     ;TO-DO: call this function from ????
            clientBuf[0] = cmdID clientBuf[1] = objID
        case 54 ; decimal value for: GC, Get Counter    ;TO-DO: call this function from ????
            clientBuf[0] = cmdID clientBuf[1] = objID
        case 80 ; decimal value for: GO, Get Config
            clientBuf[0] = cmdID clientBuf[1] = objID
        case 81 ; decimal value for: GL, Get Light
            clientBuf[0] = cmdID clientBuf[1] = objID
        case 82 ; decimal value for: GH, Get Shutter
            clientBuf[0] = cmdID clientBuf[1] = objID
        case 83 ; decimal value for: GC, Get Socket
            clientBuf[0] = cmdID clientBuf[1] = objID
        case 84 ; decimal value for: GM, Get Motion
            clientBuf[0] = cmdID clientBuf[1] = objID
        else App_Message="Invalid dScriptServer cmdID"
            return
    endselect
    dScriptServer.Write(clientBuf,3, clientBuf, clientLength)
    return
endfunction

thread dScriptServerContacter(120000)                   ; try to contact the dScriptServer at least every 10 minutes
    dScriptServerTrigger(0,0)       ; send heartbeat trigger to server   
endthread

thread CalcVoltsTemp(1000)                              ; update the systems voltage and temperature on config page (every 1 second)
    BrdTemp = ((TS1*3223)-500000)/1000              ; thread runs once per second to keep
    Volts = PSU*18369/100000                        ; board temperature and volts updated
    threadsuspend
endthread

thread Reboot(SystemReboot)                             ; thread is triggered when webpage sets "SystemReboot" to non-zero.
    x = system.Restart          ; no further processing after this  (CPU is reset)
endthread

thread ShowAppVersion(const)                            ; blink LEDs in app version used  (on demand)
    for x = 1 to AppMajor    ; flash blue led to indicate the AppVerMajor loaded
        threadsleep 500 LedBlue = on
        threadsleep 500 LedBlue = off
    next
    for x = 1 to AppMinor    ; flash green led to indicate the AppVerMinor loaded
        threadsleep 200 LedGreen = on
        threadsleep 200 LedGreen = off
    next
    threadsuspend
endthread

thread UpdateCheckedStrings(SystemCmdUpdated)           ; update the checkboxes used on config page (whenever SystemCmdUpdated is set)
    ;App_Message="UpdateCheckedStrings"
    ; different communication channels not used yet
    ;if System_Cmd==1 then ModBusChecked="checked" else ModBusChecked=" " endif
    ;if System_Cmd==2 then AsciiChecked="checked" else AsciiChecked=" " endif
    if System_Cmd==3 then BinaryChecked="checked" else BinaryChecked=" " endif
    if System_Cmd==4 then AESChecked="checked" else AESChecked=" " endif
    if System_EnablePW==1 then PWChecked="checked" else PWChecked=" " endif
    if System_EnableDHCP==1 then DHCPChecked="checked" else DHCPChecked=" " endif
    if App_EnableAutoIO==1 then 
        AutoIOChecked="checked"
        UpdateAutoIO()
    else AutoIOChecked=" " endif
    SystemCmdUpdated = 0
    threadsuspend
endthread
thread UpdateEntityCounts(App_EntityCountsUpdated)      ; update the number of lights; shutters and sockets (whenever App_EntityCountsUpdated is set)
    ;App_Message="UpdateEntityCounts"
    App_EntityCountsUpdated = 0                            ; reset trigger value initially in case there are multiple (short term) updates!
    int32 MaxRelays
    MaxRelays = 32                                         ; all boards have a maximum of 32 physical & virtual relays

    if App_Lights < 0 App_Lights = 0                       ; no negative number of lights
    if App_Shutters < 0 App_Shutters = 0                   ; no negative number of shutters
    
    ; check maximum number of arrays
    if (App_Lights + (App_Shutters*2)) > MaxRelays then     ; error here - number of relays is oversize
        if App_Lights > MaxRelays App_Lights = MaxRelays    ; never more lights than relays
    
        ; the following assumes that lights always have higher priority than shutters
        if (App_Lights + (App_Shutters*2)) > MaxRelays      ; if still more shutters & lights than relays available
            MaxRelays = MaxRelays - App_Lights              ; number of free relays
            if ( MaxRelays // 2 ) == 1 MaxRelays-=1         ; if number of free relays is Odd - make -1 (one free relay since shutters always need 2 relays)
            App_Shutters = MaxRelays/2
        endif
    endif

    ; ensure the App_LightsOffset is bigger or equal to the number of relays required by lights + shutters (since lights are counted backwards)
    if (App_Lights + (App_Shutters*2)) > App_LightsOffset then
        App_LightsOffset = (App_Lights + (App_Shutters*2)) 
    endif

    ; set the corresponding number of sockets (physical relays - lights offset)
    if App_LightsOffset >= App_PhysRelays then App_Sockets = 0 ;no negative app sockets 
    else App_Sockets = App_PhysRelays - App_LightsOffset endif
    
    UpdateAutoIO()                                      ;update the auto inputs based on number of lights & shutters
    UpdateMotions()                                     ;update the number of motions connected to system
    threadsuspend        
endthread
thread UpdateShutterStates(1000)                        ; update webpage variables for shutter states (every 1 second)
    int8 ShutterID
    int8 ShutterState
    
    for ShutterID = 1 to 16
        if App_ShutterStates[ShutterID-1] == 0 then
            ShutterState = App_ShutterLevels[ShutterID-1]
        else ShutterState = App_ShutterCLevels[ShutterID-1] endif

         select ShutterID
            case 1  App_ShutterLevel1  = ShutterState
            case 2  App_ShutterLevel2  = ShutterState
            case 3  App_ShutterLevel3  = ShutterState
            case 4  App_ShutterLevel4  = ShutterState
            case 5  App_ShutterLevel5  = ShutterState
            case 6  App_ShutterLevel6  = ShutterState
            case 7  App_ShutterLevel7  = ShutterState
            case 8  App_ShutterLevel8  = ShutterState
            case 9  App_ShutterLevel9  = ShutterState
            case 10 App_ShutterLevel10 = ShutterState
            case 11 App_ShutterLevel11 = ShutterState
            case 12 App_ShutterLevel12 = ShutterState
            case 13 App_ShutterLevel13 = ShutterState
            case 14 App_ShutterLevel14 = ShutterState
            case 15 App_ShutterLevel15 = ShutterState
            case 16 App_ShutterLevel16 = ShutterState
         endselect
    next

endthread

thread Input1(input Inp1)   ; triggered as soon as physical IO gets active
    App_IOCtr1 +=1
    App_IOActive[0] = 1
    threadsuspend
endthread
thread Input2(input Inp2)   ; triggered as soon as physical IO gets active
    App_IOCtr2 +=1
    App_IOActive[1] = 1
    threadsuspend
endthread
thread Input3(input Inp3)   ; triggered as soon as physical IO gets active
    App_IOCtr3 +=1
    App_IOActive[2] = 1
    threadsuspend
endthread
thread Input4(input Inp4)   ; triggered as soon as physical IO gets active
    App_IOCtr4 +=1
    App_IOActive[3] = 1
    threadsuspend
endthread
thread Input5(input Inp5)   ; triggered as soon as physical IO gets active
    App_IOCtr5 +=1
    App_IOActive[4] = 1
    threadsuspend
endthread
thread Input6(input Inp6)   ; triggered as soon as physical IO gets active
    App_IOCtr6 +=1
    App_IOActive[5] = 1
    threadsuspend
endthread
thread Input7(input Inp7)   ; triggered as soon as physical IO gets active
    App_IOCtr7 +=1
    App_IOActive[6] = 1
    threadsuspend
endthread
thread Input8(input Inp8)   ; triggered as soon as physical IO gets active
    App_IOCtr8 +=1
    App_IOActive[7] = 1
    threadsuspend
endthread

thread Input1off(!input Inp1)   ; triggered as soon as physical IO gets inactive
    App_IOActive[0] = 0
    threadsuspend
endthread
thread Input2off(!input Inp2)   ; triggered as soon as physical IO gets inactive
    App_IOActive[1] = 0
    threadsuspend
endthread
thread Input3off(!input Inp3)   ; triggered as soon as physical IO gets inactive
    App_IOActive[2] = 0
    threadsuspend
endthread
thread Input4off(!input Inp4)   ; triggered as soon as physical IO gets inactive
    App_IOActive[3] = 0
    threadsuspend
endthread
thread Input5off(!input Inp5)   ; triggered as soon as physical IO gets inactive
    App_IOActive[4] = 0
    threadsuspend
endthread
thread Input6off(!input Inp6)   ; triggered as soon as physical IO gets inactive
    App_IOActive[5] = 0
    threadsuspend
endthread
thread Input7off(!input Inp7)   ; triggered as soon as physical IO gets inactive
    App_IOActive[6] = 0
    threadsuspend
endthread
thread Input8off(!input Inp8)   ; triggered as soon as physical IO gets inactive
    App_IOActive[7] = 0
    threadsuspend
endthread

thread InputWeb(App_WebInput)   ; triggered as soon as a web button was pressed
    select App_WebInput
        case 1 App_IOCtr1 +=1
        case 2 App_IOCtr2 +=1
        case 3 App_IOCtr3 +=1
        case 4 App_IOCtr4 +=1
        case 5 App_IOCtr5 +=1
        case 6 App_IOCtr6 +=1
        case 7 App_IOCtr7 +=1
        case 8 App_IOCtr8 +=1
        case 99 dScriptServerTrigger(0,0)
        case 100 Init()         ; reset button on config page
    endselect
    App_WebInput=0
    threadsuspend
endthread

thread Input1IOCtr(App_IOCtr1)  ; triggered as soon as multi press counter is changed
    if App_IOType1 != 4 then
        threadsleep App_ClickSleep
    endif
    int32 Clicks
    Clicks=App_IOCtr1
    App_IOCtr1 = 0  ; ensure the CtrVal is reset for sure
    InputHandler(1,Clicks)
    threadsuspend        
endthread
thread Input2IOCtr(App_IOCtr2)  ; triggered as soon as multi press counter is changed
    if App_IOType2 != 4 then         
        threadsleep App_ClickSleep     
    endif
    int32 Clicks
    Clicks=App_IOCtr2
    App_IOCtr2 = 0  ; ensure the CtrVal is reset for sure
    InputHandler(2,Clicks)
    threadsuspend        
endthread
thread Input3IOCtr(App_IOCtr3)  ; triggered as soon as multi press counter is changed
    if App_IOType3 != 4  then         
        threadsleep App_ClickSleep     
    endif
    int32 Clicks
    Clicks=App_IOCtr3
    App_IOCtr3 = 0  ; ensure the CtrVal is reset for sure
    InputHandler(3,Clicks)
    threadsuspend        
endthread
thread Input4IOCtr(App_IOCtr4)  ; triggered as soon as multi press counter is changed
    if App_IOType4 != 4  then         
        threadsleep App_ClickSleep     
    endif
    int32 Clicks
    Clicks=App_IOCtr4
    App_IOCtr4 = 0  ; ensure the CtrVal is reset for sure
    InputHandler(4,Clicks)
    threadsuspend        
endthread
thread Input5IOCtr(App_IOCtr5)  ; triggered as soon as multi press counter is changed
    if App_IOType5 != 4  then         
        threadsleep App_ClickSleep     
    endif
    int32 Clicks
    Clicks=App_IOCtr5
    App_IOCtr5 = 0  ; ensure the CtrVal is reset for sure
    InputHandler(5,Clicks)
    threadsuspend        
endthread
thread Input6IOCtr(App_IOCtr6)  ; triggered as soon as multi press counter is changed
    if App_IOType6 != 4  then         
        threadsleep App_ClickSleep     
    endif
    int32 Clicks
    Clicks=App_IOCtr6
    App_IOCtr6 = 0  ; ensure the CtrVal is reset for sure
    InputHandler(6,Clicks)
    threadsuspend        
endthread
thread Input7IOCtr(App_IOCtr7)  ; triggered as soon as multi press counter is changed
    if App_IOType7 != 4  then         
        threadsleep App_ClickSleep     
    endif
    int32 Clicks
    Clicks=App_IOCtr7
    App_IOCtr7 = 0  ; ensure the CtrVal is reset for sure
    InputHandler(7,Clicks)
    threadsuspend        
endthread
thread Input8IOCtr(App_IOCtr8)  ; triggered as soon as multi press counter is changed
    if App_IOType8 != 4  then         
        threadsleep App_ClickSleep     
    endif
    int32 Clicks
    Clicks=App_IOCtr8
    App_IOCtr8 = 0  ; ensure the CtrVal is reset for sure
    InputHandler(8,Clicks)
    threadsuspend        
endthread

thread MoveShutter1(const)   ; handles the shutter movement and state
    ShutterMoveThreadX(1)
    threadsuspend
endthread
thread MoveShutter2(const)   ; handles the shutter movement and state
    ShutterMoveThreadX(2)
    threadsuspend
endthread
thread MoveShutter3(const)   ; handles the shutter movement and state
    ShutterMoveThreadX(3)
    threadsuspend
endthread
thread MoveShutter4(const)   ; handles the shutter movement and state
    ShutterMoveThreadX(4)
    threadsuspend
endthread
thread MoveShutter5(const)   ; handles the shutter movement and state
    ShutterMoveThreadX(5)
    threadsuspend
endthread
thread MoveShutter6(const)   ; handles the shutter movement and state
    ShutterMoveThreadX(6)
    threadsuspend
endthread
thread MoveShutter7(const)   ; handles the shutter movement and state
    ShutterMoveThreadX(7)
    threadsuspend
endthread
thread MoveShutter8(const)   ; handles the shutter movement and state
    ShutterMoveThreadX(8)
    threadsuspend
endthread
thread MoveShutter9(const)   ; handles the shutter movement and state
    ShutterMoveThreadX(9)
    threadsuspend
endthread
thread MoveShutter10(const)  ; handles the shutter movement and state
    ShutterMoveThreadX(10)
    threadsuspend
endthread
thread MoveShutter11(const)  ; handles the shutter movement and state
    ShutterMoveThreadX(11)
    threadsuspend
endthread
thread MoveShutter12(const)  ; handles the shutter movement and state
    ShutterMoveThreadX(12)
    threadsuspend
endthread
thread MoveShutter13(const)  ; handles the shutter movement and state
    ShutterMoveThreadX(13)
    threadsuspend
endthread
thread MoveShutter14(const)  ; handles the shutter movement and state
    ShutterMoveThreadX(14)
    threadsuspend
endthread
thread MoveShutter15(const)  ; handles the shutter movement and state
    ShutterMoveThreadX(15)
    threadsuspend
endthread
thread MoveShutter16(const)  ; handles the shutter movement and state
    ShutterMoveThreadX(16)
    threadsuspend
endthread

thread MoveRaffstore1(const)   ; handles the Raffstore movement and state
    RaffstoreMoveThreadX(1)
    threadsuspend
endthread
thread MoveRaffstore2(const)   ; handles the Raffstore movement and state
    RaffstoreMoveThreadX(2)
    threadsuspend
endthread
thread MoveRaffstore3(const)   ; handles the Raffstore movement and state
    RaffstoreMoveThreadX(3)
    threadsuspend
endthread
thread MoveRaffstore4(const)   ; handles the Raffstore movement and state
    RaffstoreMoveThreadX(4)
    threadsuspend
endthread
thread MoveRaffstore5(const)   ; handles the Raffstore movement and state
    RaffstoreMoveThreadX(5)
    threadsuspend
endthread
thread MoveRaffstore6(const)   ; handles the Raffstore movement and state
    RaffstoreMoveThreadX(6)
    threadsuspend
endthread
thread MoveRaffstore7(const)   ; handles the Raffstore movement and state
    RaffstoreMoveThreadX(7)
    threadsuspend
endthread
thread MoveRaffstore8(const)   ; handles the Raffstore movement and state
    RaffstoreMoveThreadX(8)
    threadsuspend
endthread
thread MoveRaffstore9(const)   ; handles the Raffstore movement and state
    RaffstoreMoveThreadX(9)
    threadsuspend
endthread
thread MoveRaffstore10(const)  ; handles the Raffstore movement and state
    RaffstoreMoveThreadX(10)
    threadsuspend
endthread
thread MoveRaffstore11(const)  ; handles the Raffstore movement and state
    RaffstoreMoveThreadX(11)
    threadsuspend
endthread
thread MoveRaffstore12(const)  ; handles the Raffstore movement and state
    RaffstoreMoveThreadX(12)
    threadsuspend
endthread
thread MoveRaffstore13(const)  ; handles the Raffstore movement and state
    RaffstoreMoveThreadX(13)
    threadsuspend
endthread
thread MoveRaffstore14(const)  ; handles the Raffstore movement and state
    RaffstoreMoveThreadX(14)
    threadsuspend
endthread
thread MoveRaffstore15(const)  ; handles the Raffstore movement and state
    RaffstoreMoveThreadX(15)
    threadsuspend
endthread
thread MoveRaffstore16(const)  ; handles the Raffstore movement and state
    RaffstoreMoveThreadX(16)
    threadsuspend
endthread

thread MotionHandler1(const)   ; handles the motion detection and state
    MotionThreadX(1)
    threadsuspend
endthread
thread MotionHandler2(const)   ; handles the motion detection and state
    MotionThreadX(2)
    threadsuspend
endthread
thread MotionHandler3(const)   ; handles the motion detection and state
    MotionThreadX(3)
    threadsuspend
endthread
thread MotionHandler4(const)   ; handles the motion detection and state
    MotionThreadX(4)
    threadsuspend
endthread
thread MotionHandler5(const)   ; handles the motion detection and state
    MotionThreadX(5)
    threadsuspend
endthread
thread MotionHandler6(const)   ; handles the motion detection and state
    MotionThreadX(6)
    threadsuspend
endthread
thread MotionHandler7(const)   ; handles the motion detection and state
    MotionThreadX(7)
    threadsuspend
endthread
thread MotionHandler8(const)   ; handles the motion detection and state
    MotionThreadX(8)
    threadsuspend
endthread

thread TcpipCmd(tcpip)         ; starts the actual tcp/ip server with defined protocol
    tcpip.Read(tcpInBuf, tcpLength)     ; read the tcp/ip data into the buffer and 
        select System_Cmd               ; branch to appropiate handler as defined in System_Cmd.
            ;case 1  ModBus()           ; not supported for now
            ;case 2  Ascii()            ; not supported for now
            case 3  Binary()
            case 4  BinaryAES()
        endselect
    threadsuspend
endthread
